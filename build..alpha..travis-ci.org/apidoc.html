<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/molnarg/node-http2"

    >http2 (v3.3.6)</a>
</h1>
<h4>An HTTP/2 client and server implementation</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2">module http2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Agent">
            function <span class="apidocSignatureSpan">http2.</span>Agent
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest">
            function <span class="apidocSignatureSpan">http2.</span>ClientRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingMessage">
            function <span class="apidocSignatureSpan">http2.</span>IncomingMessage
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingRequest">
            function <span class="apidocSignatureSpan">http2.</span>IncomingRequest
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingResponse">
            function <span class="apidocSignatureSpan">http2.</span>IncomingResponse
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingMessage">
            function <span class="apidocSignatureSpan">http2.</span>OutgoingMessage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingRequest">
            function <span class="apidocSignatureSpan">http2.</span>OutgoingRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse">
            function <span class="apidocSignatureSpan">http2.</span>OutgoingResponse
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Server">
            function <span class="apidocSignatureSpan">http2.</span>Server
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ServerResponse">
            function <span class="apidocSignatureSpan">http2.</span>ServerResponse
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.createServer">
            function <span class="apidocSignatureSpan">http2.</span>createServer
            <span class="apidocSignatureSpan">(options, requestListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.get">
            function <span class="apidocSignatureSpan">http2.</span>get
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint">
            function <span class="apidocSignatureSpan">http2.</span>protocol.Endpoint
            <span class="apidocSignatureSpan">(log, role, settings, filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.request">
            function <span class="apidocSignatureSpan">http2.</span>request
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>Agent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>ClientRequest.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>IncomingMessage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>IncomingRequest.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>IncomingResponse.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>OutgoingMessage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>OutgoingResponse.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>STATUS_CODES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>compressor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>connection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>endpoint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>flow</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>framer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>globalAgent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>protocol</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>protocol.Endpoint.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>raw</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>serializers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.</span>stream</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.Agent">module http2.Agent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Agent.Agent">
            function <span class="apidocSignatureSpan">http2.</span>Agent
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.Agent.prototype">module http2.Agent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Agent.prototype.destroy">
            function <span class="apidocSignatureSpan">http2.Agent.prototype.</span>destroy
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Agent.prototype.get">
            function <span class="apidocSignatureSpan">http2.Agent.prototype.</span>get
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Agent.prototype.request">
            function <span class="apidocSignatureSpan">http2.Agent.prototype.</span>request
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.ClientRequest">module http2.ClientRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest.ClientRequest">
            function <span class="apidocSignatureSpan">http2.</span>ClientRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.ClientRequest.prototype">module http2.ClientRequest.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest.prototype._fallback">
            function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>_fallback
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest.prototype._onPromise">
            function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>_onPromise
            <span class="apidocSignatureSpan">(stream, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest.prototype._start">
            function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>_start
            <span class="apidocSignatureSpan">(stream, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest.prototype.abort">
            function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest.prototype.on">
            function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>on
            <span class="apidocSignatureSpan">(event, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest.prototype.setNoDelay">
            function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>setNoDelay
            <span class="apidocSignatureSpan">(noDelay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest.prototype.setPriority">
            function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>setPriority
            <span class="apidocSignatureSpan">(priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest.prototype.setSocketKeepAlive">
            function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>setSocketKeepAlive
            <span class="apidocSignatureSpan">(enable, initialDelay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.ClientRequest.prototype.setTimeout">
            function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>setTimeout
            <span class="apidocSignatureSpan">(timeout, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.IncomingMessage">module http2.IncomingMessage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingMessage.IncomingMessage">
            function <span class="apidocSignatureSpan">http2.</span>IncomingMessage
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.IncomingMessage.prototype">module http2.IncomingMessage.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingMessage.prototype._checkSpecialHeader">
            function <span class="apidocSignatureSpan">http2.IncomingMessage.prototype.</span>_checkSpecialHeader
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingMessage.prototype._onEnd">
            function <span class="apidocSignatureSpan">http2.IncomingMessage.prototype.</span>_onEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingMessage.prototype._onHeaders">
            function <span class="apidocSignatureSpan">http2.IncomingMessage.prototype.</span>_onHeaders
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingMessage.prototype._validateHeaders">
            function <span class="apidocSignatureSpan">http2.IncomingMessage.prototype.</span>_validateHeaders
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingMessage.prototype.setTimeout">
            function <span class="apidocSignatureSpan">http2.IncomingMessage.prototype.</span>setTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.IncomingRequest">module http2.IncomingRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingRequest.IncomingRequest">
            function <span class="apidocSignatureSpan">http2.</span>IncomingRequest
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.IncomingRequest.prototype">module http2.IncomingRequest.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingRequest.prototype._onHeaders">
            function <span class="apidocSignatureSpan">http2.IncomingRequest.prototype.</span>_onHeaders
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.IncomingResponse">module http2.IncomingResponse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingResponse.IncomingResponse">
            function <span class="apidocSignatureSpan">http2.</span>IncomingResponse
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.IncomingResponse.prototype">module http2.IncomingResponse.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.IncomingResponse.prototype._onHeaders">
            function <span class="apidocSignatureSpan">http2.IncomingResponse.prototype.</span>_onHeaders
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.OutgoingMessage">module http2.OutgoingMessage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingMessage.OutgoingMessage">
            function <span class="apidocSignatureSpan">http2.</span>OutgoingMessage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.OutgoingMessage.prototype">module http2.OutgoingMessage.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingMessage.prototype._checkSpecialHeader">
            function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>_checkSpecialHeader
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingMessage.prototype._finish">
            function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>_finish
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingMessage.prototype._write">
            function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingMessage.prototype.addTrailers">
            function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>addTrailers
            <span class="apidocSignatureSpan">(trailers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingMessage.prototype.getHeader">
            function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>getHeader
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingMessage.prototype.removeHeader">
            function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>removeHeader
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingMessage.prototype.setHeader">
            function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>setHeader
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingMessage.prototype.setTimeout">
            function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>setTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.OutgoingResponse">module http2.OutgoingResponse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse.OutgoingResponse">
            function <span class="apidocSignatureSpan">http2.</span>OutgoingResponse
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.OutgoingResponse.prototype">module http2.OutgoingResponse.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse.prototype._implicitHeader">
            function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>_implicitHeader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse.prototype._implicitHeaders">
            function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>_implicitHeaders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse.prototype._onRequestHeaders">
            function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>_onRequestHeaders
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse.prototype.altsvc">
            function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>altsvc
            <span class="apidocSignatureSpan">(host, port, protocolID, maxAge, origin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse.prototype.end">
            function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse.prototype.on">
            function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>on
            <span class="apidocSignatureSpan">(event, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse.prototype.push">
            function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>push
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse.prototype.write">
            function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.OutgoingResponse.prototype.writeHead">
            function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>writeHead
            <span class="apidocSignatureSpan">(statusCode, reasonPhrase, headers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.Server">module http2.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Server.Server">
            function <span class="apidocSignatureSpan">http2.</span>Server
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.Server.prototype">module http2.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Server.prototype._fallback">
            function <span class="apidocSignatureSpan">http2.Server.prototype.</span>_fallback
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Server.prototype._start">
            function <span class="apidocSignatureSpan">http2.Server.prototype.</span>_start
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Server.prototype.addContext">
            function <span class="apidocSignatureSpan">http2.Server.prototype.</span>addContext
            <span class="apidocSignatureSpan">(hostname, credentials)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Server.prototype.address">
            function <span class="apidocSignatureSpan">http2.Server.prototype.</span>address
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Server.prototype.close">
            function <span class="apidocSignatureSpan">http2.Server.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Server.prototype.listen">
            function <span class="apidocSignatureSpan">http2.Server.prototype.</span>listen
            <span class="apidocSignatureSpan">(port, hostname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Server.prototype.on">
            function <span class="apidocSignatureSpan">http2.Server.prototype.</span>on
            <span class="apidocSignatureSpan">(event, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.Server.prototype.setTimeout">
            function <span class="apidocSignatureSpan">http2.Server.prototype.</span>setTimeout
            <span class="apidocSignatureSpan">(timeout, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.compressor">module http2.compressor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.compressor.Compressor">
            function <span class="apidocSignatureSpan">http2.compressor.</span>Compressor
            <span class="apidocSignatureSpan">(log, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.compressor.Decompressor">
            function <span class="apidocSignatureSpan">http2.compressor.</span>Decompressor
            <span class="apidocSignatureSpan">(log, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.compressor.HeaderSetCompressor">
            function <span class="apidocSignatureSpan">http2.compressor.</span>HeaderSetCompressor
            <span class="apidocSignatureSpan">(log, table)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.compressor.HeaderSetDecompressor">
            function <span class="apidocSignatureSpan">http2.compressor.</span>HeaderSetDecompressor
            <span class="apidocSignatureSpan">(log, table)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.compressor.HeaderTable">
            function <span class="apidocSignatureSpan">http2.compressor.</span>HeaderTable
            <span class="apidocSignatureSpan">(log, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.compressor.HuffmanTable">
            function <span class="apidocSignatureSpan">http2.compressor.</span>HuffmanTable
            <span class="apidocSignatureSpan">(table)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.connection">module http2.connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.connection.Connection">
            function <span class="apidocSignatureSpan">http2.connection.</span>Connection
            <span class="apidocSignatureSpan">(log, firstStreamId, settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.endpoint">module http2.endpoint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.endpoint.Endpoint">
            function <span class="apidocSignatureSpan">http2.endpoint.</span>Endpoint
            <span class="apidocSignatureSpan">(log, role, settings, filters)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.endpoint.</span>serializers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.flow">module http2.flow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.flow.Flow">
            function <span class="apidocSignatureSpan">http2.flow.</span>Flow
            <span class="apidocSignatureSpan">(flowControlId)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.framer">module http2.framer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.framer.Deserializer">
            function <span class="apidocSignatureSpan">http2.framer.</span>Deserializer
            <span class="apidocSignatureSpan">(log, role)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.framer.Serializer">
            function <span class="apidocSignatureSpan">http2.framer.</span>Serializer
            <span class="apidocSignatureSpan">(log)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.framer.</span>serializers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.http">module http2.http</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.http.createServer">
            function <span class="apidocSignatureSpan">http2.http.</span>createServer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.http.get">
            function <span class="apidocSignatureSpan">http2.http.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.http.request">
            function <span class="apidocSignatureSpan">http2.http.</span>request
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.https">module http2.https</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.https.createServer">
            function <span class="apidocSignatureSpan">http2.https.</span>createServer
            <span class="apidocSignatureSpan">(options, requestListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.https.get">
            function <span class="apidocSignatureSpan">http2.https.</span>get
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.https.request">
            function <span class="apidocSignatureSpan">http2.https.</span>request
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.protocol">module http2.protocol</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint">
            function <span class="apidocSignatureSpan">http2.protocol.</span>Endpoint
            <span class="apidocSignatureSpan">(log, role, settings, filters)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.protocol.</span>serializers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">http2.protocol.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.protocol.Endpoint">module http2.protocol.Endpoint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.Endpoint">
            function <span class="apidocSignatureSpan">http2.protocol.</span>Endpoint
            <span class="apidocSignatureSpan">(log, role, settings, filters)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.protocol.Endpoint.prototype">module http2.protocol.Endpoint.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.prototype._error">
            function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_error
            <span class="apidocSignatureSpan">(component, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.prototype._initializeDataFlow">
            function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_initializeDataFlow
            <span class="apidocSignatureSpan">(role, settings, filters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.prototype._initializeErrorHandling">
            function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_initializeErrorHandling
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.prototype._initializeManagement">
            function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_initializeManagement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.prototype._read">
            function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.prototype._readPrelude">
            function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_readPrelude
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.prototype._write">
            function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_write
            <span class="apidocSignatureSpan">(chunk, encoding, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.prototype._writePrelude">
            function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_writePrelude
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.prototype.close">
            function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>close
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.protocol.Endpoint.prototype.createStream">
            function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>createStream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.raw">module http2.raw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.raw.createServer">
            function <span class="apidocSignatureSpan">http2.raw.</span>createServer
            <span class="apidocSignatureSpan">(options, requestListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.raw.get">
            function <span class="apidocSignatureSpan">http2.raw.</span>get
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.raw.request">
            function <span class="apidocSignatureSpan">http2.raw.</span>request
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.serializers">module http2.serializers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.serializers.data">
            function <span class="apidocSignatureSpan">http2.serializers.</span>data
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.serializers.e">
            function <span class="apidocSignatureSpan">http2.serializers.</span>e
            <span class="apidocSignatureSpan">(endpoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.serializers.frame">
            function <span class="apidocSignatureSpan">http2.serializers.</span>frame
            <span class="apidocSignatureSpan">(frame)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.serializers.s">
            function <span class="apidocSignatureSpan">http2.serializers.</span>s
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.http2.stream">module http2.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.http2.stream.Stream">
            function <span class="apidocSignatureSpan">http2.stream.</span>Stream
            <span class="apidocSignatureSpan">(log, connection)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">http2.stream.</span>serializers</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2" id="apidoc.module.http2">module http2</a></h1>


    <h2>
        <a href="#apidoc.element.http2.Agent" id="apidoc.element.http2.Agent">
        function <span class="apidocSignatureSpan">http2.</span>Agent
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  EventEmitter.call(this);
  this.setMaxListeners(0);

  options = util._extend({}, options);

  this._settings = options.settings;
  this._log = (options.log || defaultLogger).child({ component: &#x27;http&#x27; });
  this.endpoints = {};

  // * Using an own HTTPS agent, because the global agent does not look at `NPN/ALPNProtocols` when
  //   generating the key identifying the connection, so we may get useless non-negotiated TLS
  //   channels even if we ask for a negotiated one. This agent will contain only negotiated
  //   channels.
  options.ALPNProtocols = supportedProtocols;
  options.NPNProtocols = supportedProtocols;
  this._httpsAgent = new https.Agent(options);

  this.sockets = this._httpsAgent.sockets;
  this.requests = this._httpsAgent.requests;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var fs = require(&#x27;fs&#x27;);
var path = require(&#x27;path&#x27;);
var http2 = require(&#x27;..&#x27;);
var urlParse = require(&#x27;url&#x27;).parse;

// Setting the global logger (optional)
http2.globalAgent = new http2.<span class="apidocCodeKeywordSpan">Agent</span>({
  rejectUnauthorized: true,
  log: require(&#x27;../test/util&#x27;).createLogger(&#x27;client&#x27;)
});

// Sending the request
var url = process.argv.pop();
var options = urlParse(url);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.ClientRequest" id="apidoc.element.http2.ClientRequest">
        function <span class="apidocSignatureSpan">http2.</span>ClientRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OutgoingRequest() {
  OutgoingMessage.call(this);

  this._log = undefined;

  this.stream = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.IncomingMessage" id="apidoc.element.http2.IncomingMessage">
        function <span class="apidocSignatureSpan">http2.</span>IncomingMessage
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IncomingMessage(stream) {
  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.
  PassThrough.call(this);
  stream.pipe(this);
  this.socket = this.stream = stream;

  this._log = stream._log.child({ component: &#x27;http&#x27; });

  // * HTTP/2.0 does not define a way to carry the version identifier that is included in the
  //   HTTP/1.1 request/status line. Version is always 2.0.
  this.httpVersion = &#x27;2.0&#x27;;
  this.httpVersionMajor = 2;
  this.httpVersionMinor = 0;

  // * `this.headers` will store the regular headers (and none of the special colon headers)
  this.headers = {};
  this.trailers = undefined;
  this._lastHeadersSeen = undefined;

  // * Other metadata is filled in when the headers arrive.
  stream.once(&#x27;headers&#x27;, this._onHeaders.bind(this));
  stream.once(&#x27;end&#x27;, this._onEnd.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.IncomingRequest" id="apidoc.element.http2.IncomingRequest">
        function <span class="apidocSignatureSpan">http2.</span>IncomingRequest
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IncomingRequest(stream) {
  IncomingMessage.call(this, stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.IncomingResponse" id="apidoc.element.http2.IncomingResponse">
        function <span class="apidocSignatureSpan">http2.</span>IncomingResponse
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IncomingResponse(stream) {
  IncomingMessage.call(this, stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingMessage" id="apidoc.element.http2.OutgoingMessage">
        function <span class="apidocSignatureSpan">http2.</span>OutgoingMessage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OutgoingMessage() {
  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.
  Writable.call(this);

  this._headers = {};
  this._trailers = undefined;
  this.headersSent = false;
  this.finished = false;

  this.on(&#x27;finish&#x27;, this._finish);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingRequest" id="apidoc.element.http2.OutgoingRequest">
        function <span class="apidocSignatureSpan">http2.</span>OutgoingRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OutgoingRequest() {
  OutgoingMessage.call(this);

  this._log = undefined;

  this.stream = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse" id="apidoc.element.http2.OutgoingResponse">
        function <span class="apidocSignatureSpan">http2.</span>OutgoingResponse
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OutgoingResponse(stream) {
  OutgoingMessage.call(this);

  this._log = stream._log.child({ component: &#x27;http&#x27; });

  this.stream = stream;
  this.statusCode = 200;
  this.sendDate = true;

  this.stream.once(&#x27;headers&#x27;, this._onRequestHeaders.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.Server" id="apidoc.element.http2.Server">
        function <span class="apidocSignatureSpan">http2.</span>Server
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options) {
  options = util._extend({}, options);

  this._log = (options.log || defaultLogger).child({ component: &#x27;http&#x27; });
  this._settings = options.settings;

  var start = this._start.bind(this);
  var fallback = this._fallback.bind(this);

  // HTTP2 over TLS (using NPN or ALPN)
  if ((options.key &#x26;&#x26; options.cert) || options.pfx) {
    this._log.info(&#x27;Creating HTTP/2 server over TLS&#x27;);
    this._mode = &#x27;tls&#x27;;
    options.ALPNProtocols = supportedProtocols;
    options.NPNProtocols = supportedProtocols;
    options.ciphers = options.ciphers || cipherSuites;
    options.honorCipherOrder = (options.honorCipherOrder != false);
    this._server = https.createServer(options);
    this._originalSocketListeners = this._server.listeners(&#x27;secureConnection&#x27;);
    this._server.removeAllListeners(&#x27;secureConnection&#x27;);
    this._server.on(&#x27;secureConnection&#x27;, function(socket) {
      var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;
      // It&#x27;s true that the client MUST use SNI, but if it doesn&#x27;t, we don&#x27;t care, don&#x27;t fall back to HTTP/1,
      // since if the ALPN negotiation is otherwise successful, the client thinks we speak HTTP/2 but we don&#x27;t.
      if (negotiatedProtocol === protocol.VERSION) {
        start(socket);
      } else {
        fallback(socket);
      }
    });
    this._server.on(&#x27;request&#x27;, this.emit.bind(this, &#x27;request&#x27;));

    forwardEvent(&#x27;error&#x27;, this._server, this);
    forwardEvent(&#x27;listening&#x27;, this._server, this);
  }

  // HTTP2 over plain TCP
  else if (options.plain) {
    this._log.info(&#x27;Creating HTTP/2 server over plain TCP&#x27;);
    this._mode = &#x27;plain&#x27;;
    this._server = net.createServer(start);
  }

  // HTTP/2 with HTTP/1.1 upgrade
  else {
    this._log.error(&#x27;Trying to create HTTP/2 server with Upgrade from HTTP/1.1&#x27;);
    throw new Error(&#x27;HTTP1.1 -&#x3e; HTTP2 upgrade is not yet supported. Please provide TLS keys.&#x27;);
  }

  this._server.on(&#x27;close&#x27;, this.emit.bind(this, &#x27;close&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.ServerResponse" id="apidoc.element.http2.ServerResponse">
        function <span class="apidocSignatureSpan">http2.</span>ServerResponse
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OutgoingResponse(stream) {
  OutgoingMessage.call(this);

  this._log = stream._log.child({ component: &#x27;http&#x27; });

  this.stream = stream;
  this.statusCode = 200;
  this.sendDate = true;

  this.stream.once(&#x27;headers&#x27;, this._onRequestHeaders.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.createServer" id="apidoc.element.http2.createServer">
        function <span class="apidocSignatureSpan">http2.</span>createServer
        <span class="apidocSignatureSpan">(options, requestListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServerTLS(options, requestListener) {
  if (typeof options === &#x27;function&#x27;) {
    throw new Error(&#x27;options are required!&#x27;);
  }
  if (!options.pfx &#x26;&#x26; !(options.key &#x26;&#x26; options.cert)) {
    throw new Error(&#x27;options.pfx or options.key and options.cert are required!&#x27;);
  }
  options.plain = false;

  var server = new Server(options);

  if (requestListener) {
    server.on(&#x27;request&#x27;, requestListener);
  }

  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var options = {
  key: fs.readFileSync(&#x27;./example/localhost.key&#x27;),
  cert: fs.readFileSync(&#x27;./example/localhost.crt&#x27;)
};

require(&#x27;http2&#x27;).<span class="apidocCodeKeywordSpan">createServer</span>(options, function(request, response) {
  response.end(&#x27;Hello world!&#x27;);
}).listen(8080);
```

### Using as a client ###

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.get" id="apidoc.element.http2.get">
        function <span class="apidocSignatureSpan">http2.</span>get
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTLS(options, callback) {
  if (typeof options === &#x22;string&#x22;) {
    options = url.parse(options);
  }
  options.plain = false;
  if (options.protocol &#x26;&#x26; options.protocol !== &#x22;https:&#x22;) {
    throw new Error(&#x27;This interface only supports https-schemed URLs&#x27;);
  }
  if (options.agent &#x26;&#x26; typeof(options.agent.get) === &#x27;function&#x27;) {
    var agentOptions = util._extend({}, options);
    delete agentOptions.agent;
    return options.agent.get(agentOptions, callback);
  }
  return exports.globalAgent.get(options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  response.end(&#x27;Hello world!&#x27;);
}).listen(8080);
```

### Using as a client ###

```javascript
require(&#x27;http2&#x27;).<span class="apidocCodeKeywordSpan">get</span>(&#x27;https://localhost:8080/&#x27;, function(response
) {
  response.pipe(process.stdout);
});
```

### Simple static file server ###

An simple static file server serving up content from its own directory is available in the `example`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint" id="apidoc.element.http2.protocol.Endpoint">
        function <span class="apidocSignatureSpan">http2.</span>protocol.Endpoint
        <span class="apidocSignatureSpan">(log, role, settings, filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Endpoint(log, role, settings, filters) {
  Duplex.call(this);

  // * Initializing logging infrastructure
  this._log = log.child({ component: &#x27;endpoint&#x27;, e: this });

  // * First part of the handshake process: sending and receiving the client connection header
  //   prelude.
  assert((role === &#x27;CLIENT&#x27;) || role === &#x27;SERVER&#x27;);
  if (role === &#x27;CLIENT&#x27;) {
    this._writePrelude();
  } else {
    this._readPrelude();
  }

  // * Initialization of component. This includes the second part of the handshake process:
  //   sending the first SETTINGS frame. This is done by the connection class right after
  //   initialization.
  this._initializeDataFlow(role, settings, filters || {});

  // * Initialization of management code.
  this._initializeManagement();

  // * Initializing error handling.
  this._initializeErrorHandling();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.request" id="apidoc.element.http2.request">
        function <span class="apidocSignatureSpan">http2.</span>request
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function requestTLS(options, callback) {
  if (typeof options === &#x22;string&#x22;) {
    options = url.parse(options);
  }
  options.plain = false;
  if (options.protocol &#x26;&#x26; options.protocol !== &#x22;https:&#x22;) {
    throw new Error(&#x27;This interface only supports https-schemed URLs&#x27;);
  }
  if (options.agent &#x26;&#x26; typeof(options.agent.request) === &#x27;function&#x27;) {
    var agentOptions = util._extend({}, options);
    delete agentOptions.agent;
    return options.agent.request(agentOptions, callback);
  }
  return exports.globalAgent.request(options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.Agent**
//   - **new Agent(options)**: additional option:
//     - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object
//   - **agent.sockets**: only contains TCP sockets that corresponds to HTTP/1 requests.
//   - **agent.endpoints**: contains [Endpoint](protocol/endpoint.html) objects for HTTP/2 connections.
//
// - **http2.<span class="apidocCodeKeywordSpan">request</span>(options, [callback])**:
//   - similar to http.request
//
// - **http2.get(options, [callback])**:
//   - similar to http.get
//
// - **Class: http2.ClientRequest**
//   - **Event: &#x27;socket&#x27; (socket)**: in case of an HTTP/2 incoming message, `socket` is a reference
...</pre></li>
    </ul>














































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.Agent" id="apidoc.module.http2.Agent">module http2.Agent</a></h1>


    <h2>
        <a href="#apidoc.element.http2.Agent.Agent" id="apidoc.element.http2.Agent.Agent">
        function <span class="apidocSignatureSpan">http2.</span>Agent
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(options) {
  EventEmitter.call(this);
  this.setMaxListeners(0);

  options = util._extend({}, options);

  this._settings = options.settings;
  this._log = (options.log || defaultLogger).child({ component: &#x27;http&#x27; });
  this.endpoints = {};

  // * Using an own HTTPS agent, because the global agent does not look at `NPN/ALPNProtocols` when
  //   generating the key identifying the connection, so we may get useless non-negotiated TLS
  //   channels even if we ask for a negotiated one. This agent will contain only negotiated
  //   channels.
  options.ALPNProtocols = supportedProtocols;
  options.NPNProtocols = supportedProtocols;
  this._httpsAgent = new https.Agent(options);

  this.sockets = this._httpsAgent.sockets;
  this.requests = this._httpsAgent.requests;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var fs = require(&#x27;fs&#x27;);
var path = require(&#x27;path&#x27;);
var http2 = require(&#x27;..&#x27;);
var urlParse = require(&#x27;url&#x27;).parse;

// Setting the global logger (optional)
http2.globalAgent = new http2.<span class="apidocCodeKeywordSpan">Agent</span>({
  rejectUnauthorized: true,
  log: require(&#x27;../test/util&#x27;).createLogger(&#x27;client&#x27;)
});

// Sending the request
var url = process.argv.pop();
var options = urlParse(url);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.Agent.prototype" id="apidoc.module.http2.Agent.prototype">module http2.Agent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http2.Agent.prototype.destroy" id="apidoc.element.http2.Agent.prototype.destroy">
        function <span class="apidocSignatureSpan">http2.Agent.prototype.</span>destroy
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (error) {
  if (this._httpsAgent) {
    this._httpsAgent.destroy();
  }
  for (var key in this.endpoints) {
    this.endpoints[key].close(error);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var request = this.request(options, callback);
  request.end();
  return request;
};

Agent.prototype.destroy = function(error) {
  if (this._httpsAgent) {
    this._httpsAgent.<span class="apidocCodeKeywordSpan">destroy</span>();
  }
  for (var key in this.endpoints) {
    this.endpoints[key].close(error);
  }
};

function unbundleSocket(socket) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.Agent.prototype.get" id="apidoc.element.http2.Agent.prototype.get">
        function <span class="apidocSignatureSpan">http2.Agent.prototype.</span>get
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(options, callback) {
  var request = this.request(options, callback);
  request.end();
  return request;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  response.end(&#x27;Hello world!&#x27;);
}).listen(8080);
```

### Using as a client ###

```javascript
require(&#x27;http2&#x27;).<span class="apidocCodeKeywordSpan">get</span>(&#x27;https://localhost:8080/&#x27;, function(response
) {
  response.pipe(process.stdout);
});
```

### Simple static file server ###

An simple static file server serving up content from its own directory is available in the `example`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.Agent.prototype.request" id="apidoc.element.http2.Agent.prototype.request">
        function <span class="apidocSignatureSpan">http2.Agent.prototype.</span>request
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function request(options, callback) {
  if (typeof options === &#x27;string&#x27;) {
    options = url.parse(options);
  } else {
    options = util._extend({}, options);
  }

  options.method = (options.method || &#x27;GET&#x27;).toUpperCase();
  options.protocol = options.protocol || &#x27;https:&#x27;;
  options.host = options.hostname || options.host || &#x27;localhost&#x27;;
  options.port = options.port || 443;
  options.path = options.path || &#x27;/&#x27;;

  if (!options.plain &#x26;&#x26; options.protocol === &#x27;http:&#x27;) {
    this._log.error(&#x27;Trying to negotiate client request with Upgrade from HTTP/1.1&#x27;);
    this.emit(&#x27;error&#x27;, new Error(&#x27;HTTP1.1 -&#x3e; HTTP2 upgrade is not yet supported.&#x27;));
  }

  var request = new OutgoingRequest(this._log);

  if (callback) {
    request.on(&#x27;response&#x27;, callback);
  }

  var key = [
    !!options.plain,
    options.host,
    options.port
  ].join(&#x27;:&#x27;);
  var self = this;

  // * There&#x27;s an existing HTTP/2 connection to this host
  if (key in this.endpoints) {
    var endpoint = this.endpoints[key];
    request._start(endpoint.createStream(), options);
  }

  // * HTTP/2 over plain TCP
  else if (options.plain) {
    endpoint = new Endpoint(this._log, &#x27;CLIENT&#x27;, this._settings);
    endpoint.socket = net.connect({
      host: options.host,
      port: options.port,
      localAddress: options.localAddress
    });

    endpoint.socket.on(&#x27;error&#x27;, function (error) {
      self._log.error(&#x27;Socket error: &#x27; + error.toString());
      request.emit(&#x27;error&#x27;, error);
    });

    endpoint.on(&#x27;error&#x27;, function(error){
      self._log.error(&#x27;Connection error: &#x27; + error.toString());
      request.emit(&#x27;error&#x27;, error);
    });

    this.endpoints[key] = endpoint;
    endpoint.pipe(endpoint.socket).pipe(endpoint);
    request._start(endpoint.createStream(), options);
  }

  // * HTTP/2 over TLS negotiated using NPN or ALPN, or fallback to HTTPS1
  else {
    var started = false;
    var createAgent = hasAgentOptions(options);
    options.ALPNProtocols = supportedProtocols;
    options.NPNProtocols = supportedProtocols;
    options.servername = options.host; // Server Name Indication
    options.ciphers = options.ciphers || cipherSuites;
    if (createAgent) {
      options.agent = new https.Agent(options);
    } else if (options.agent == null) {
      options.agent = this._httpsAgent;
    }
    var httpsRequest = https.request(options);

    httpsRequest.on(&#x27;error&#x27;, function (error) {
      self._log.error(&#x27;Socket error: &#x27; + error.toString());
      self.removeAllListeners(key);
      request.emit(&#x27;error&#x27;, error);
    });

    httpsRequest.on(&#x27;socket&#x27;, function(socket) {
      var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;
      if (negotiatedProtocol != null) { // null in &#x3e;=0.11.0, undefined in &#x3c;0.11.0
        negotiated();
      } else {
        socket.on(&#x27;secureConnect&#x27;, negotiated);
      }
    });

    function negotiated() {
      var endpoint;
      var negotiatedProtocol = httpsRequest.socket.alpnProtocol || httpsRequest.socket.npnProtocol;
      if (negotiatedProtocol === protocol.VERSION) {
        httpsRequest.socket.emit(&#x27;agentRemove&#x27;);
        unbundleSocket(httpsRequest.socket);
        endpoint = new Endpoint(self._log, &#x27;CLIENT&#x27;, self._settings);
        endpoint.socket = httpsRequest.socket;
        endpoint.pipe(endpoint.socket).pipe(endpoint);
      }
      if (started) {
        // ** In the meantime, an other connection was made to the same host...
        if (endpoint) {
          // *** and it turned out to be HTTP2 and the request was multiplexed on that one, so we should close this one
          endpoint.close();
        }
        // *** otherwise, the fallback to HTTPS1 is already done.
      } else {
        if (endpoint) {
          self._log.info({ e: endpoint, server: options.host + &#x27;:&#x27; + options.port },
                         &#x27;New outgoing HTTP/2 connection&#x27;);
          self.endpoints[key] = endpoint;
          self.emit(key, endpoint);
        } else {
          self.emit(key, undefined);
        }
      }
    }

    this.once(key, function(endpoint) {
      started = true;
      if (endpoint) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.Agent**
//   - **new Agent(options)**: additional option:
//     - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object
//   - **agent.sockets**: only contains TCP sockets that corresponds to HTTP/1 requests.
//   - **agent.endpoints**: contains [Endpoint](protocol/endpoint.html) objects for HTTP/2 connections.
//
// - **http2.<span class="apidocCodeKeywordSpan">request</span>(options, [callback])**:
//   - similar to http.request
//
// - **http2.get(options, [callback])**:
//   - similar to http.get
//
// - **Class: http2.ClientRequest**
//   - **Event: &#x27;socket&#x27; (socket)**: in case of an HTTP/2 incoming message, `socket` is a reference
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.ClientRequest" id="apidoc.module.http2.ClientRequest">module http2.ClientRequest</a></h1>


    <h2>
        <a href="#apidoc.element.http2.ClientRequest.ClientRequest" id="apidoc.element.http2.ClientRequest.ClientRequest">
        function <span class="apidocSignatureSpan">http2.</span>ClientRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OutgoingRequest() {
  OutgoingMessage.call(this);

  this._log = undefined;

  this.stream = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.ClientRequest.prototype" id="apidoc.module.http2.ClientRequest.prototype">module http2.ClientRequest.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http2.ClientRequest.prototype._fallback" id="apidoc.element.http2.ClientRequest.prototype._fallback">
        function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>_fallback
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _fallback(request) {
  request.on(&#x27;response&#x27;, this.emit.bind(this, &#x27;response&#x27;));
  this.stream = this.request = request;
  this.emit(&#x27;socket&#x27;, this.socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    this.once(key, function(endpoint) {
      started = true;
      if (endpoint) {
        request._start(endpoint.createStream(), options);
      } else {
        request.<span class="apidocCodeKeywordSpan">_fallback</span>(httpsRequest);
      }
    });
  }

  return request;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.ClientRequest.prototype._onPromise" id="apidoc.element.http2.ClientRequest.prototype._onPromise">
        function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>_onPromise
        <span class="apidocSignatureSpan">(stream, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onPromise(stream, headers) {
  this._log.info({ push_stream: stream.id }, &#x27;Receiving push promise&#x27;);

  var promise = new IncomingPromise(stream, headers);

  if (this.listeners(&#x27;push&#x27;).length &#x3e; 0) {
    this.emit(&#x27;push&#x27;, promise);
  } else {
    promise.cancel();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (frame.type === &#x27;HEADERS&#x27;) {
  if (this._processedHeaders &#x26;&#x26; !frame.flags[&#x27;END_STREAM&#x27;]) {
    this.emit(&#x27;error&#x27;, &#x27;PROTOCOL_ERROR&#x27;);
  }
  this._processedHeaders = true;
  this._onHeaders(frame);
} else if (frame.type === &#x27;PUSH_PROMISE&#x27;) {
  this.<span class="apidocCodeKeywordSpan">_onPromise</span>(frame);
} else if (frame.type === &#x27;PRIORITY&#x27;) {
  this._onPriority(frame);
} else if (frame.type === &#x27;ALTSVC&#x27;) {
  // TODO
} else if (frame.type === &#x27;BLOCKED&#x27;) {
  // TODO
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.ClientRequest.prototype._start" id="apidoc.element.http2.ClientRequest.prototype._start">
        function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>_start
        <span class="apidocSignatureSpan">(stream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _start(stream, options) {
  this.stream = stream;
  this.options = options;

  this._log = stream._log.child({ component: &#x27;http&#x27; });

  for (var key in options.headers) {
    this.setHeader(key, options.headers[key]);
  }
  var headers = this._headers;
  delete headers.host;

  if (options.auth) {
    headers.authorization = &#x27;Basic &#x27; + new Buffer(options.auth).toString(&#x27;base64&#x27;);
  }

  headers[&#x27;:scheme&#x27;] = options.protocol.slice(0, -1);
  headers[&#x27;:method&#x27;] = options.method;
  headers[&#x27;:authority&#x27;] = options.host;
  headers[&#x27;:path&#x27;] = options.path;

  this._log.info({ scheme: headers[&#x27;:scheme&#x27;], method: headers[&#x27;:method&#x27;],
                   authority: headers[&#x27;:authority&#x27;], path: headers[&#x27;:path&#x27;],
                   headers: (options.headers || {}) }, &#x27;Sending request&#x27;);
  this.stream.headers(headers);
  this.headersSent = true;

  this.emit(&#x27;socket&#x27;, this.stream);
  var response = new IncomingResponse(this.stream);
  response.req = this;
  response.once(&#x27;ready&#x27;, this.emit.bind(this, &#x27;response&#x27;, response));

  this.stream.on(&#x27;promise&#x27;, this._onPromise.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options.port
].join(&#x27;:&#x27;);
var self = this;

// * There&#x27;s an existing HTTP/2 connection to this host
if (key in this.endpoints) {
  var endpoint = this.endpoints[key];
  request.<span class="apidocCodeKeywordSpan">_start</span>(endpoint.createStream(), options);
}

// * HTTP/2 over plain TCP
else if (options.plain) {
  endpoint = new Endpoint(this._log, &#x27;CLIENT&#x27;, this._settings);
  endpoint.socket = net.connect({
    host: options.host,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.ClientRequest.prototype.abort" id="apidoc.element.http2.ClientRequest.prototype.abort">
        function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abort() {
  if (this.request) {
    this.request.abort();
  } else if (this.stream) {
    this.stream.reset(&#x27;CANCEL&#x27;);
  } else {
    this.on(&#x27;socket&#x27;, this.abort.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.on(&#x27;socket&#x27;, this.setTimeout.bind(this, timeout, callback));
  }
};

// Aborting the request
OutgoingRequest.prototype.abort = function abort() {
  if (this.request) {
    this.request.<span class="apidocCodeKeywordSpan">abort</span>();
  } else if (this.stream) {
    this.stream.reset(&#x27;CANCEL&#x27;);
  } else {
    this.on(&#x27;socket&#x27;, this.abort.bind(this));
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.ClientRequest.prototype.on" id="apidoc.element.http2.ClientRequest.prototype.on">
        function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>on
        <span class="apidocSignatureSpan">(event, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, listener) {
  if (this.request &#x26;&#x26; (event === &#x27;upgrade&#x27;)) {
    this.request.on(event, listener &#x26;&#x26; listener.bind(this));
  } else {
    OutgoingMessage.prototype.on.call(this, event, listener);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options.key = fs.readFileSync(path.join(__dirname, &#x27;/localhost.key&#x27;));
options.ca = fs.readFileSync(path.join(__dirname, &#x27;/localhost.crt&#x27;));
}

var request = process.env.HTTP2_PLAIN ? http2.raw.get(options) : http2.get(options);

// Receiving the response
request.<span class="apidocCodeKeywordSpan">on</span>(&#x27;response&#x27;, function(response) {
response.pipe(process.stdout);
response.on(&#x27;end&#x27;, finish);
});

// Receiving push streams
request.on(&#x27;push&#x27;, function(pushRequest) {
var filename = path.join(__dirname, &#x27;/push-&#x27; + push_count);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.ClientRequest.prototype.setNoDelay" id="apidoc.element.http2.ClientRequest.prototype.setNoDelay">
        function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>setNoDelay
        <span class="apidocSignatureSpan">(noDelay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setNoDelay(noDelay) {
  if (this.request) {
    this.request.setNoDelay(noDelay);
  } else if (!this.stream) {
    this.on(&#x27;socket&#x27;, this.setNoDelay.bind(this, noDelay));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//     one connection per host.
//
// - **Class: http2.ClientRequest**
//   - **Event: &#x27;upgrade&#x27;**
//   - **Event: &#x27;connect&#x27;**
//   - **Event: &#x27;continue&#x27;**
//   - **request.setTimeout(timeout, [callback])**
//   - **request.<span class="apidocCodeKeywordSpan">setNoDelay</span>([noDelay])**
//   - **request.setSocketKeepAlive([enable], [initialDelay])**
//
// - **Class: http2.IncomingMessage**
//   - **Event: &#x27;close&#x27;**
//   - **message.setTimeout(timeout, [callback])**
//
// [1]: https://nodejs.org/api/https.html
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.ClientRequest.prototype.setPriority" id="apidoc.element.http2.ClientRequest.prototype.setPriority">
        function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>setPriority
        <span class="apidocSignatureSpan">(priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setPriority(priority) {
  if (this.stream) {
    this.stream.priority(priority);
  } else {
    this.once(&#x27;socket&#x27;, this.setPriority.bind(this, priority));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.ClientRequest**
//   - **Event: &#x27;socket&#x27; (socket)**: in case of an HTTP/2 incoming message, `socket` is a reference
//     to the associated [HTTP/2 Stream](protocol/stream.html) object (and not to the TCP socket).
//   - **Event: &#x27;push&#x27; (promise)**: signals the intention of a server push associated to this
//     request. `promise` is an IncomingPromise. If there&#x27;s no listener for this event, the server
//     push is cancelled.
//   - **request.<span class="apidocCodeKeywordSpan">setPriority</span>(priority)**: assign a priority to this request. `priority
` is a number
//     between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.
//
// - **Class: http2.IncomingMessage**
//   - has two subclasses for easier interface description: **IncomingRequest** and
//     **IncomingResponse**
//   - **message.socket**: in case of an HTTP/2 incoming message, it&#x27;s a reference to the associated
//     [HTTP/2 Stream](protocol/stream.html) object (and not to the TCP socket).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.ClientRequest.prototype.setSocketKeepAlive" id="apidoc.element.http2.ClientRequest.prototype.setSocketKeepAlive">
        function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>setSocketKeepAlive
        <span class="apidocSignatureSpan">(enable, initialDelay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setSocketKeepAlive(enable, initialDelay) {
  if (this.request) {
    this.request.setSocketKeepAlive(enable, initialDelay);
  } else if (!this.stream) {
    this.on(&#x27;socket&#x27;, this.setSocketKeepAlive.bind(this, enable, initialDelay));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.ClientRequest**
//   - **Event: &#x27;upgrade&#x27;**
//   - **Event: &#x27;connect&#x27;**
//   - **Event: &#x27;continue&#x27;**
//   - **request.setTimeout(timeout, [callback])**
//   - **request.setNoDelay([noDelay])**
//   - **request.<span class="apidocCodeKeywordSpan">setSocketKeepAlive</span>([enable], [initialDelay])**
//
// - **Class: http2.IncomingMessage**
//   - **Event: &#x27;close&#x27;**
//   - **message.setTimeout(timeout, [callback])**
//
// [1]: https://nodejs.org/api/https.html
// [2]: https://nodejs.org/api/http.html
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.ClientRequest.prototype.setTimeout" id="apidoc.element.http2.ClientRequest.prototype.setTimeout">
        function <span class="apidocSignatureSpan">http2.ClientRequest.prototype.</span>setTimeout
        <span class="apidocSignatureSpan">(timeout, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTimeout(timeout, callback) {
  if (this.request) {
    this.request.setTimeout(timeout, callback);
  } else if (!this.stream) {
    this.on(&#x27;socket&#x27;, this.setTimeout.bind(this, timeout, callback));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.Server**
//   - **Event: &#x27;checkContinue&#x27;**: not in the spec
//   - **Event: &#x27;upgrade&#x27;**: upgrade is deprecated in HTTP/2
//   - **Event: &#x27;timeout&#x27;**: HTTP/2 sockets won&#x27;t timeout because of application level keepalive
//     (PING frames)
//   - **Event: &#x27;connect&#x27;**: not yet supported
//   - **server.<span class="apidocCodeKeywordSpan">setTimeout</span>(msecs, [callback])**
//   - **server.timeout**
//
// - **Class: http2.ServerResponse**
//   - **Event: &#x27;close&#x27;**
//   - **Event: &#x27;timeout&#x27;**
//   - **response.writeContinue()**
//   - **response.writeHead(statusCode, [reasonPhrase], [headers])**: reasonPhrase will always be
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.IncomingMessage" id="apidoc.module.http2.IncomingMessage">module http2.IncomingMessage</a></h1>


    <h2>
        <a href="#apidoc.element.http2.IncomingMessage.IncomingMessage" id="apidoc.element.http2.IncomingMessage.IncomingMessage">
        function <span class="apidocSignatureSpan">http2.</span>IncomingMessage
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IncomingMessage(stream) {
  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.
  PassThrough.call(this);
  stream.pipe(this);
  this.socket = this.stream = stream;

  this._log = stream._log.child({ component: &#x27;http&#x27; });

  // * HTTP/2.0 does not define a way to carry the version identifier that is included in the
  //   HTTP/1.1 request/status line. Version is always 2.0.
  this.httpVersion = &#x27;2.0&#x27;;
  this.httpVersionMajor = 2;
  this.httpVersionMinor = 0;

  // * `this.headers` will store the regular headers (and none of the special colon headers)
  this.headers = {};
  this.trailers = undefined;
  this._lastHeadersSeen = undefined;

  // * Other metadata is filled in when the headers arrive.
  stream.once(&#x27;headers&#x27;, this._onHeaders.bind(this));
  stream.once(&#x27;end&#x27;, this._onEnd.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.IncomingMessage.prototype" id="apidoc.module.http2.IncomingMessage.prototype">module http2.IncomingMessage.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http2.IncomingMessage.prototype._checkSpecialHeader" id="apidoc.element.http2.IncomingMessage.prototype._checkSpecialHeader">
        function <span class="apidocSignatureSpan">http2.IncomingMessage.prototype.</span>_checkSpecialHeader
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _checkSpecialHeader(key, value) {
  if ((typeof value !== &#x27;string&#x27;) || (value.length === 0)) {
    this._log.error({ key: key, value: value }, &#x27;Invalid or missing special header field&#x27;);
    this.stream.reset(&#x27;PROTOCOL_ERROR&#x27;);
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// * The &#x22;:path&#x22; header field includes the path and query parts of the target URI.
//   This field MUST NOT be empty; URIs that do not contain a path component MUST include a value
//   of &#x27;/&#x27;, unless the request is an OPTIONS request for &#x27;*&#x27;, in which case the &#x22;:path&#x22; header
//   field MUST include &#x27;*&#x27;.
// * All HTTP/2.0 requests MUST include exactly one valid value for all of these header fields. A
//   server MUST treat the absence of any of these header fields, presence of multiple values, or
//   an invalid value as a stream error of type PROTOCOL_ERROR.
this.method = this.<span class="apidocCodeKeywordSpan">_checkSpecialHeader</span>(&#x27;:method&#x27;   , headers[&#x27;:method&#
x27;]);
this.scheme = this._checkSpecialHeader(&#x27;:scheme&#x27;   , headers[&#x27;:scheme&#x27;]);
this.host   = this._checkSpecialHeader(&#x27;:authority&#x27;, headers[&#x27;:authority&#x27;]  );
this.url    = this._checkSpecialHeader(&#x27;:path&#x27;     , headers[&#x27;:path&#x27;]  );
if (!this.method || !this.scheme || !this.host || !this.url) {
  // This is invalid, and we&#x27;ve sent a RST_STREAM, so don&#x27;t continue processing
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.IncomingMessage.prototype._onEnd" id="apidoc.element.http2.IncomingMessage.prototype._onEnd">
        function <span class="apidocSignatureSpan">http2.IncomingMessage.prototype.</span>_onEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onEnd() {
  this.trailers = this._lastHeadersSeen;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.IncomingMessage.prototype._onHeaders" id="apidoc.element.http2.IncomingMessage.prototype._onHeaders">
        function <span class="apidocSignatureSpan">http2.IncomingMessage.prototype.</span>_onHeaders
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onHeaders(headers) {
  // * Detects malformed headers
  this._validateHeaders(headers);

  // * Store the _regular_ headers in `this.headers`
  for (var name in headers) {
    if (name[0] !== &#x27;:&#x27;) {
      if (name === &#x27;set-cookie&#x27; &#x26;&#x26; !Array.isArray(headers[name])) {
        this.headers[name] = [headers[name]];
      } else {
        this.headers[name] = headers[name];
      }
    }
  }

  // * The last header block, if it&#x27;s not the first, will represent the trailers
  var self = this;
  this.stream.on(&#x27;headers&#x27;, function(headers) {
    self._lastHeadersSeen = headers;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var stream = new Readable();
stream._read = noop;
stream.push(null);
stream._log = responseStream._log;

IncomingRequest.call(this, stream);

this.<span class="apidocCodeKeywordSpan">_onHeaders</span>(promiseHeaders);

this._responseStream = responseStream;

var response = new IncomingResponse(this._responseStream);
response.once(&#x27;ready&#x27;, this.emit.bind(this, &#x27;response&#x27;, response));

this.stream.on(&#x27;promise&#x27;, this._onPromise.bind(this));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.IncomingMessage.prototype._validateHeaders" id="apidoc.element.http2.IncomingMessage.prototype._validateHeaders">
        function <span class="apidocSignatureSpan">http2.IncomingMessage.prototype.</span>_validateHeaders
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _validateHeaders(headers) {
  // * An HTTP/2.0 request or response MUST NOT include any of the following header fields:
  //   Connection, Host, Keep-Alive, Proxy-Connection, Transfer-Encoding, and Upgrade. A server
  //   MUST treat the presence of any of these header fields as a stream error of type
  //   PROTOCOL_ERROR.
  //  If the TE header is present, it&#x27;s only valid value is &#x27;trailers&#x27;
  for (var i = 0; i &#x3c; deprecatedHeaders.length; i++) {
    var key = deprecatedHeaders[i];
    if (key in headers || (key === &#x27;te&#x27; &#x26;&#x26; headers[key] !== &#x27;trailers&#x27;)) {
      this._log.error({ key: key, value: headers[key] }, &#x27;Deprecated header found&#x27;);
      this.stream.reset(&#x27;PROTOCOL_ERROR&#x27;);
      return;
    }
  }

  for (var headerName in headers) {
    // * Empty header name field is malformed
    if (headerName.length &#x3c;= 1) {
      this.stream.reset(&#x27;PROTOCOL_ERROR&#x27;);
      return;
    }
    // * A request or response containing uppercase header name field names MUST be
    //   treated as malformed (Section 8.1.3.5). Implementations that detect malformed
    //   requests or responses need to ensure that the stream ends.
    if(/[A-Z]/.test(headerName)) {
      this.stream.reset(&#x27;PROTOCOL_ERROR&#x27;);
      return;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// [Request Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)
// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series
//   of key-value pairs. This includes the target URI for the request, the status code for the
//   response, as well as HTTP header fields.
IncomingMessage.prototype._onHeaders = function _onHeaders(headers) {
// * Detects malformed headers
this.<span class="apidocCodeKeywordSpan">_validateHeaders</span>(headers);

// * Store the _regular_ headers in `this.headers`
for (var name in headers) {
  if (name[0] !== &#x27;:&#x27;) {
    if (name === &#x27;set-cookie&#x27; &#x26;&#x26; !Array.isArray(headers[name])) {
      this.headers[name] = [headers[name]];
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.IncomingMessage.prototype.setTimeout" id="apidoc.element.http2.IncomingMessage.prototype.setTimeout">
        function <span class="apidocSignatureSpan">http2.IncomingMessage.prototype.</span>setTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.Server**
//   - **Event: &#x27;checkContinue&#x27;**: not in the spec
//   - **Event: &#x27;upgrade&#x27;**: upgrade is deprecated in HTTP/2
//   - **Event: &#x27;timeout&#x27;**: HTTP/2 sockets won&#x27;t timeout because of application level keepalive
//     (PING frames)
//   - **Event: &#x27;connect&#x27;**: not yet supported
//   - **server.<span class="apidocCodeKeywordSpan">setTimeout</span>(msecs, [callback])**
//   - **server.timeout**
//
// - **Class: http2.ServerResponse**
//   - **Event: &#x27;close&#x27;**
//   - **Event: &#x27;timeout&#x27;**
//   - **response.writeContinue()**
//   - **response.writeHead(statusCode, [reasonPhrase], [headers])**: reasonPhrase will always be
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.IncomingRequest" id="apidoc.module.http2.IncomingRequest">module http2.IncomingRequest</a></h1>


    <h2>
        <a href="#apidoc.element.http2.IncomingRequest.IncomingRequest" id="apidoc.element.http2.IncomingRequest.IncomingRequest">
        function <span class="apidocSignatureSpan">http2.</span>IncomingRequest
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IncomingRequest(stream) {
  IncomingMessage.call(this, stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.IncomingRequest.prototype" id="apidoc.module.http2.IncomingRequest.prototype">module http2.IncomingRequest.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http2.IncomingRequest.prototype._onHeaders" id="apidoc.element.http2.IncomingRequest.prototype._onHeaders">
        function <span class="apidocSignatureSpan">http2.IncomingRequest.prototype.</span>_onHeaders
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onHeaders(headers) {
  // * The &#x22;:method&#x22; header field includes the HTTP method
  // * The &#x22;:scheme&#x22; header field includes the scheme portion of the target URI
  // * The &#x22;:authority&#x22; header field includes the authority portion of the target URI
  // * The &#x22;:path&#x22; header field includes the path and query parts of the target URI.
  //   This field MUST NOT be empty; URIs that do not contain a path component MUST include a value
  //   of &#x27;/&#x27;, unless the request is an OPTIONS request for &#x27;*&#x27;, in which case the &#x22;:path&#x22; header
  //   field MUST include &#x27;*&#x27;.
  // * All HTTP/2.0 requests MUST include exactly one valid value for all of these header fields. A
  //   server MUST treat the absence of any of these header fields, presence of multiple values, or
  //   an invalid value as a stream error of type PROTOCOL_ERROR.
  this.method = this._checkSpecialHeader(&#x27;:method&#x27;   , headers[&#x27;:method&#x27;]);
  this.scheme = this._checkSpecialHeader(&#x27;:scheme&#x27;   , headers[&#x27;:scheme&#x27;]);
  this.host   = this._checkSpecialHeader(&#x27;:authority&#x27;, headers[&#x27;:authority&#x27;]  );
  this.url    = this._checkSpecialHeader(&#x27;:path&#x27;     , headers[&#x27;:path&#x27;]  );
  if (!this.method || !this.scheme || !this.host || !this.url) {
    // This is invalid, and we&#x27;ve sent a RST_STREAM, so don&#x27;t continue processing
    return;
  }

  // * Host header is included in the headers object for backwards compatibility.
  this.headers.host = this.host;

  // * Handling regular headers.
  IncomingMessage.prototype._onHeaders.call(this, headers);

  // * Signaling that the headers arrived.
  this._log.info({ method: this.method, scheme: this.scheme, host: this.host,
                   path: this.url, headers: this.headers }, &#x27;Incoming request&#x27;);
  this.emit(&#x27;ready&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var stream = new Readable();
stream._read = noop;
stream.push(null);
stream._log = responseStream._log;

IncomingRequest.call(this, stream);

this.<span class="apidocCodeKeywordSpan">_onHeaders</span>(promiseHeaders);

this._responseStream = responseStream;

var response = new IncomingResponse(this._responseStream);
response.once(&#x27;ready&#x27;, this.emit.bind(this, &#x27;response&#x27;, response));

this.stream.on(&#x27;promise&#x27;, this._onPromise.bind(this));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.IncomingResponse" id="apidoc.module.http2.IncomingResponse">module http2.IncomingResponse</a></h1>


    <h2>
        <a href="#apidoc.element.http2.IncomingResponse.IncomingResponse" id="apidoc.element.http2.IncomingResponse.IncomingResponse">
        function <span class="apidocSignatureSpan">http2.</span>IncomingResponse
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IncomingResponse(stream) {
  IncomingMessage.call(this, stream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.IncomingResponse.prototype" id="apidoc.module.http2.IncomingResponse.prototype">module http2.IncomingResponse.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http2.IncomingResponse.prototype._onHeaders" id="apidoc.element.http2.IncomingResponse.prototype._onHeaders">
        function <span class="apidocSignatureSpan">http2.IncomingResponse.prototype.</span>_onHeaders
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onHeaders(headers) {
  // * A single &#x22;:status&#x22; header field is defined that carries the HTTP status code field. This
  //   header field MUST be included in all responses.
  // * A client MUST treat the absence of the &#x22;:status&#x22; header field, the presence of multiple
  //   values, or an invalid value as a stream error of type PROTOCOL_ERROR.
  //   Note: currently, we do not enforce it strictly: we accept any format, and parse it as int
  // * HTTP/2.0 does not define a way to carry the reason phrase that is included in an HTTP/1.1
  //   status line.
  this.statusCode = parseInt(this._checkSpecialHeader(&#x27;:status&#x27;, headers[&#x27;:status&#x27;]));

  // * Handling regular headers.
  IncomingMessage.prototype._onHeaders.call(this, headers);

  // * Signaling that the headers arrived.
  this._log.info({ status: this.statusCode, headers: this.headers}, &#x27;Incoming response&#x27;);
  this.emit(&#x27;ready&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var stream = new Readable();
stream._read = noop;
stream.push(null);
stream._log = responseStream._log;

IncomingRequest.call(this, stream);

this.<span class="apidocCodeKeywordSpan">_onHeaders</span>(promiseHeaders);

this._responseStream = responseStream;

var response = new IncomingResponse(this._responseStream);
response.once(&#x27;ready&#x27;, this.emit.bind(this, &#x27;response&#x27;, response));

this.stream.on(&#x27;promise&#x27;, this._onPromise.bind(this));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.OutgoingMessage" id="apidoc.module.http2.OutgoingMessage">module http2.OutgoingMessage</a></h1>


    <h2>
        <a href="#apidoc.element.http2.OutgoingMessage.OutgoingMessage" id="apidoc.element.http2.OutgoingMessage.OutgoingMessage">
        function <span class="apidocSignatureSpan">http2.</span>OutgoingMessage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OutgoingMessage() {
  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.
  Writable.call(this);

  this._headers = {};
  this._trailers = undefined;
  this.headersSent = false;
  this.finished = false;

  this.on(&#x27;finish&#x27;, this._finish);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.OutgoingMessage.prototype" id="apidoc.module.http2.OutgoingMessage.prototype">module http2.OutgoingMessage.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http2.OutgoingMessage.prototype._checkSpecialHeader" id="apidoc.element.http2.OutgoingMessage.prototype._checkSpecialHeader">
        function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>_checkSpecialHeader
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _checkSpecialHeader(key, value) {
  if ((typeof value !== &#x27;string&#x27;) || (value.length === 0)) {
    this._log.error({ key: key, value: value }, &#x27;Invalid or missing special header field&#x27;);
    this.stream.reset(&#x27;PROTOCOL_ERROR&#x27;);
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// * The &#x22;:path&#x22; header field includes the path and query parts of the target URI.
//   This field MUST NOT be empty; URIs that do not contain a path component MUST include a value
//   of &#x27;/&#x27;, unless the request is an OPTIONS request for &#x27;*&#x27;, in which case the &#x22;:path&#x22; header
//   field MUST include &#x27;*&#x27;.
// * All HTTP/2.0 requests MUST include exactly one valid value for all of these header fields. A
//   server MUST treat the absence of any of these header fields, presence of multiple values, or
//   an invalid value as a stream error of type PROTOCOL_ERROR.
this.method = this.<span class="apidocCodeKeywordSpan">_checkSpecialHeader</span>(&#x27;:method&#x27;   , headers[&#x27;:method&#
x27;]);
this.scheme = this._checkSpecialHeader(&#x27;:scheme&#x27;   , headers[&#x27;:scheme&#x27;]);
this.host   = this._checkSpecialHeader(&#x27;:authority&#x27;, headers[&#x27;:authority&#x27;]  );
this.url    = this._checkSpecialHeader(&#x27;:path&#x27;     , headers[&#x27;:path&#x27;]  );
if (!this.method || !this.scheme || !this.host || !this.url) {
  // This is invalid, and we&#x27;ve sent a RST_STREAM, so don&#x27;t continue processing
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingMessage.prototype._finish" id="apidoc.element.http2.OutgoingMessage.prototype._finish">
        function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>_finish
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _finish() {
  if (this.stream) {
    if (this._trailers) {
      if (this.request) {
        this.request.addTrailers(this._trailers);
      } else {
        this.stream.headers(this._trailers);
      }
    }
    this.finished = true;
    this.stream.end();
  } else {
    this.once(&#x27;socket&#x27;, this._finish.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingMessage.prototype._write" id="apidoc.element.http2.OutgoingMessage.prototype._write">
        function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _write(chunk, encoding, callback) {
  if (this.stream) {
    this.stream.write(chunk, encoding, callback);
  } else {
    this.once(&#x27;socket&#x27;, this._write.bind(this, chunk, encoding, callback));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // * if the whole header is over, and there were no error then restore the original `_write`
    //   and call it with the remaining part of the current chunk
    if (cursor === CLIENT_PRELUDE.length) {
      this._log.debug(&#x27;Successfully received the client connection header prelude.&#x27;);
      delete this._write;
      chunk = chunk.slice(cursor - offset);
      this.<span class="apidocCodeKeywordSpan">_write</span>(chunk, encoding, done);
    }
  };
};

// Data flow
// ---------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingMessage.prototype.addTrailers" id="apidoc.element.http2.OutgoingMessage.prototype.addTrailers">
        function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>addTrailers
        <span class="apidocSignatureSpan">(trailers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addTrailers(trailers) {
  this._trailers = trailers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
};

OutgoingMessage.prototype._finish = function _finish() {
if (this.stream) {
  if (this._trailers) {
    if (this.request) {
      this.request.<span class="apidocCodeKeywordSpan">addTrailers</span>(this._trailers);
    } else {
      this.stream.headers(this._trailers);
    }
  }
  this.finished = true;
  this.stream.end();
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingMessage.prototype.getHeader" id="apidoc.element.http2.OutgoingMessage.prototype.getHeader">
        function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>getHeader
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHeader(name) {
  return this._headers[name.toLowerCase()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingMessage.prototype.removeHeader" id="apidoc.element.http2.OutgoingMessage.prototype.removeHeader">
        function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>removeHeader
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeHeader(name) {
  if (this.headersSent) {
    return this.emit(&#x27;error&#x27;, new Error(&#x27;Can\&#x27;t remove headers after they are sent.&#x27;));
  } else {
    delete this._headers[name.toLowerCase()];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingMessage.prototype.setHeader" id="apidoc.element.http2.OutgoingMessage.prototype.setHeader">
        function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>setHeader
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setHeader(name, value) {
  if (this.headersSent) {
    return this.emit(&#x27;error&#x27;, new Error(&#x27;Can\&#x27;t set headers after they are sent.&#x27;));
  } else {
    name = name.toLowerCase();
    if (deprecatedHeaders.indexOf(name) !== -1) {
      return this.emit(&#x27;error&#x27;, new Error(&#x27;Cannot set deprecated header: &#x27; + name));
    }
    this._headers[name] = value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof reasonPhrase === &#x27;string&#x27;) {
  this._log.warn(&#x27;Reason phrase argument was present but ignored by the writeHead method&#x27;);
} else {
  headers = reasonPhrase;
}

for (var name in headers) {
  this.<span class="apidocCodeKeywordSpan">setHeader</span>(name, headers[name]);
}
headers = this._headers;

if (this.sendDate &#x26;&#x26; !(&#x27;date&#x27; in this._headers)) {
  headers.date = (new Date()).toUTCString();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingMessage.prototype.setTimeout" id="apidoc.element.http2.OutgoingMessage.prototype.setTimeout">
        function <span class="apidocSignatureSpan">http2.OutgoingMessage.prototype.</span>setTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.Server**
//   - **Event: &#x27;checkContinue&#x27;**: not in the spec
//   - **Event: &#x27;upgrade&#x27;**: upgrade is deprecated in HTTP/2
//   - **Event: &#x27;timeout&#x27;**: HTTP/2 sockets won&#x27;t timeout because of application level keepalive
//     (PING frames)
//   - **Event: &#x27;connect&#x27;**: not yet supported
//   - **server.<span class="apidocCodeKeywordSpan">setTimeout</span>(msecs, [callback])**
//   - **server.timeout**
//
// - **Class: http2.ServerResponse**
//   - **Event: &#x27;close&#x27;**
//   - **Event: &#x27;timeout&#x27;**
//   - **response.writeContinue()**
//   - **response.writeHead(statusCode, [reasonPhrase], [headers])**: reasonPhrase will always be
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.OutgoingResponse" id="apidoc.module.http2.OutgoingResponse">module http2.OutgoingResponse</a></h1>


    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse.OutgoingResponse" id="apidoc.element.http2.OutgoingResponse.OutgoingResponse">
        function <span class="apidocSignatureSpan">http2.</span>OutgoingResponse
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OutgoingResponse(stream) {
  OutgoingMessage.call(this);

  this._log = stream._log.child({ component: &#x27;http&#x27; });

  this.stream = stream;
  this.statusCode = 200;
  this.sendDate = true;

  this.stream.once(&#x27;headers&#x27;, this._onRequestHeaders.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.OutgoingResponse.prototype" id="apidoc.module.http2.OutgoingResponse.prototype">module http2.OutgoingResponse.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse.prototype._implicitHeader" id="apidoc.element.http2.OutgoingResponse.prototype._implicitHeader">
        function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>_implicitHeader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_implicitHeader = function () {
  this._implicitHeaders();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse.prototype._implicitHeaders" id="apidoc.element.http2.OutgoingResponse.prototype._implicitHeaders">
        function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>_implicitHeaders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _implicitHeaders() {
  if (!this.headersSent) {
    this.writeHead(this.statusCode);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
OutgoingResponse.prototype._implicitHeaders = function _implicitHeaders() {
  if (!this.headersSent) {
    this.writeHead(this.statusCode);
  }
};

OutgoingResponse.prototype._implicitHeader = function() {
  this.<span class="apidocCodeKeywordSpan">_implicitHeaders</span>();
};

OutgoingResponse.prototype.write = function write() {
  this._implicitHeaders();
  return OutgoingMessage.prototype.write.apply(this, arguments);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse.prototype._onRequestHeaders" id="apidoc.element.http2.OutgoingResponse.prototype._onRequestHeaders">
        function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>_onRequestHeaders
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onRequestHeaders(headers) {
  this._requestHeaders = headers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse.prototype.altsvc" id="apidoc.element.http2.OutgoingResponse.prototype.altsvc">
        function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>altsvc
        <span class="apidocSignatureSpan">(host, port, protocolID, maxAge, origin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function altsvc(host, port, protocolID, maxAge, origin) {
    if (origin === undefined) {
        origin = &#x22;&#x22;;
    }
    this.stream.altsvc(host, port, protocolID, maxAge, origin);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return new OutgoingResponse(pushStream);
};

OutgoingResponse.prototype.altsvc = function altsvc(host, port, protocolID, maxAge, origin) {
  if (origin === undefined) {
      origin = &#x22;&#x22;;
  }
  this.stream.<span class="apidocCodeKeywordSpan">altsvc</span>(host, port, protocolID, maxAge, origin);
};

// Overriding `EventEmitter`&#x27;s `on(event, listener)` method to forward certain subscriptions to
// `request`. See `Server.prototype.on` for explanation.
OutgoingResponse.prototype.on = function on(event, listener) {
if (this.request &#x26;&#x26; (event === &#x27;timeout&#x27;)) {
  this.request.on(event, listener &#x26;&#x26; listener.bind(this));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse.prototype.end" id="apidoc.element.http2.OutgoingResponse.prototype.end">
        function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function end() {
  this.finshed = true;
  this._implicitHeaders();
  return OutgoingMessage.prototype.end.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var options = {
  key: fs.readFileSync(&#x27;./example/localhost.key&#x27;),
  cert: fs.readFileSync(&#x27;./example/localhost.crt&#x27;)
};

require(&#x27;http2&#x27;).createServer(options, function(request, response) {
  response.<span class="apidocCodeKeywordSpan">end</span>(&#x27;Hello world!&#x27;);
}).listen(8080);
```

### Using as a client ###

```javascript
require(&#x27;http2&#x27;).get(&#x27;https://localhost:8080/&#x27;, function(response) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse.prototype.on" id="apidoc.element.http2.OutgoingResponse.prototype.on">
        function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>on
        <span class="apidocSignatureSpan">(event, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, listener) {
  if (this.request &#x26;&#x26; (event === &#x27;timeout&#x27;)) {
    this.request.on(event, listener &#x26;&#x26; listener.bind(this));
  } else {
    OutgoingMessage.prototype.on.call(this, event, listener);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options.key = fs.readFileSync(path.join(__dirname, &#x27;/localhost.key&#x27;));
options.ca = fs.readFileSync(path.join(__dirname, &#x27;/localhost.crt&#x27;));
}

var request = process.env.HTTP2_PLAIN ? http2.raw.get(options) : http2.get(options);

// Receiving the response
request.<span class="apidocCodeKeywordSpan">on</span>(&#x27;response&#x27;, function(response) {
response.pipe(process.stdout);
response.on(&#x27;end&#x27;, finish);
});

// Receiving push streams
request.on(&#x27;push&#x27;, function(pushRequest) {
var filename = path.join(__dirname, &#x27;/push-&#x27; + push_count);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse.prototype.push" id="apidoc.element.http2.OutgoingResponse.prototype.push">
        function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>push
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function push(options) {
  if (typeof options === &#x27;string&#x27;) {
    options = url.parse(options);
  }

  if (!options.path) {
    throw new Error(&#x27;`path` option is mandatory.&#x27;);
  }

  var promise = util._extend({
    &#x27;:method&#x27;: (options.method || &#x27;GET&#x27;).toUpperCase(),
    &#x27;:scheme&#x27;: (options.protocol &#x26;&#x26; options.protocol.slice(0, -1)) || this._requestHeaders[&#x27;:scheme&#x27;],
    &#x27;:authority&#x27;: options.hostname || options.host || this._requestHeaders[&#x27;:authority&#x27;],
    &#x27;:path&#x27;: options.path
  }, options.headers);

  this._log.info({ method: promise[&#x27;:method&#x27;], scheme: promise[&#x27;:scheme&#x27;],
                   authority: promise[&#x27;:authority&#x27;], path: promise[&#x27;:path&#x27;],
                   headers: options.headers }, &#x27;Promising push stream&#x27;);

  var pushStream = this.stream.promise(promise);

  return new OutgoingResponse(pushStream);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var filename = path.join(__dirname, request.url);

// Serving server.js from cache. Useful for microbenchmarks.
if (request.url === cachedUrl) {
  if (response.push) {
    // Also push down the client js, since it&#x27;s possible if the requester wants
    // one, they want both.
    var push = response.<span class="apidocCodeKeywordSpan">push</span>(&#x27;/client.js&#x27;);
    push.writeHead(200);
    fs.createReadStream(path.join(__dirname, &#x27;/client.js&#x27;)).pipe(push);
  }
  response.end(cachedFile);
}

// Reading file from disk if it exists and is safe.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse.prototype.write" id="apidoc.element.http2.OutgoingResponse.prototype.write">
        function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write() {
  this._implicitHeaders();
  return OutgoingMessage.prototype.write.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.on(&#x27;finish&#x27;, this._finish);
}
OutgoingMessage.prototype = Object.create(Writable.prototype, { constructor: { value: OutgoingMessage } });

OutgoingMessage.prototype._write = function _write(chunk, encoding, callback) {
if (this.stream) {
  this.stream.<span class="apidocCodeKeywordSpan">write</span>(chunk, encoding, callback);
} else {
  this.once(&#x27;socket&#x27;, this._write.bind(this, chunk, encoding, callback));
}
};

OutgoingMessage.prototype._finish = function _finish() {
if (this.stream) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.OutgoingResponse.prototype.writeHead" id="apidoc.element.http2.OutgoingResponse.prototype.writeHead">
        function <span class="apidocSignatureSpan">http2.OutgoingResponse.prototype.</span>writeHead
        <span class="apidocSignatureSpan">(statusCode, reasonPhrase, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeHead(statusCode, reasonPhrase, headers) {
  if (this.headersSent) {
    return;
  }

  if (typeof reasonPhrase === &#x27;string&#x27;) {
    this._log.warn(&#x27;Reason phrase argument was present but ignored by the writeHead method&#x27;);
  } else {
    headers = reasonPhrase;
  }

  for (var name in headers) {
    this.setHeader(name, headers[name]);
  }
  headers = this._headers;

  if (this.sendDate &#x26;&#x26; !(&#x27;date&#x27; in this._headers)) {
    headers.date = (new Date()).toUTCString();
  }

  this._log.info({ status: statusCode, headers: this._headers }, &#x27;Sending server response&#x27;);

  headers[&#x27;:status&#x27;] = this.statusCode = statusCode;

  this.stream.headers(headers);
  this.headersSent = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Serving server.js from cache. Useful for microbenchmarks.
if (request.url === cachedUrl) {
  if (response.push) {
    // Also push down the client js, since it&#x27;s possible if the requester wants
    // one, they want both.
    var push = response.push(&#x27;/client.js&#x27;);
    push.<span class="apidocCodeKeywordSpan">writeHead</span>(200);
    fs.createReadStream(path.join(__dirname, &#x27;/client.js&#x27;)).pipe(push);
  }
  response.end(cachedFile);
}

// Reading file from disk if it exists and is safe.
else if ((filename.indexOf(__dirname) === 0) &#x26;&#x26; fs.existsSync(filename) &#x26;&#x26; fs.statSync(filename).isFile()) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.Server" id="apidoc.module.http2.Server">module http2.Server</a></h1>


    <h2>
        <a href="#apidoc.element.http2.Server.Server" id="apidoc.element.http2.Server.Server">
        function <span class="apidocSignatureSpan">http2.</span>Server
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options) {
  options = util._extend({}, options);

  this._log = (options.log || defaultLogger).child({ component: &#x27;http&#x27; });
  this._settings = options.settings;

  var start = this._start.bind(this);
  var fallback = this._fallback.bind(this);

  // HTTP2 over TLS (using NPN or ALPN)
  if ((options.key &#x26;&#x26; options.cert) || options.pfx) {
    this._log.info(&#x27;Creating HTTP/2 server over TLS&#x27;);
    this._mode = &#x27;tls&#x27;;
    options.ALPNProtocols = supportedProtocols;
    options.NPNProtocols = supportedProtocols;
    options.ciphers = options.ciphers || cipherSuites;
    options.honorCipherOrder = (options.honorCipherOrder != false);
    this._server = https.createServer(options);
    this._originalSocketListeners = this._server.listeners(&#x27;secureConnection&#x27;);
    this._server.removeAllListeners(&#x27;secureConnection&#x27;);
    this._server.on(&#x27;secureConnection&#x27;, function(socket) {
      var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;
      // It&#x27;s true that the client MUST use SNI, but if it doesn&#x27;t, we don&#x27;t care, don&#x27;t fall back to HTTP/1,
      // since if the ALPN negotiation is otherwise successful, the client thinks we speak HTTP/2 but we don&#x27;t.
      if (negotiatedProtocol === protocol.VERSION) {
        start(socket);
      } else {
        fallback(socket);
      }
    });
    this._server.on(&#x27;request&#x27;, this.emit.bind(this, &#x27;request&#x27;));

    forwardEvent(&#x27;error&#x27;, this._server, this);
    forwardEvent(&#x27;listening&#x27;, this._server, this);
  }

  // HTTP2 over plain TCP
  else if (options.plain) {
    this._log.info(&#x27;Creating HTTP/2 server over plain TCP&#x27;);
    this._mode = &#x27;plain&#x27;;
    this._server = net.createServer(start);
  }

  // HTTP/2 with HTTP/1.1 upgrade
  else {
    this._log.error(&#x27;Trying to create HTTP/2 server with Upgrade from HTTP/1.1&#x27;);
    throw new Error(&#x27;HTTP1.1 -&#x3e; HTTP2 upgrade is not yet supported. Please provide TLS keys.&#x27;);
  }

  this._server.on(&#x27;close&#x27;, this.emit.bind(this, &#x27;close&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.Server.prototype" id="apidoc.module.http2.Server.prototype">module http2.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http2.Server.prototype._fallback" id="apidoc.element.http2.Server.prototype._fallback">
        function <span class="apidocSignatureSpan">http2.Server.prototype.</span>_fallback
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _fallback(socket) {
  var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;

  this._log.info({ client: socket.remoteAddress + &#x27;:&#x27; + socket.remotePort,
                   protocol: negotiatedProtocol,
                   SNI: socket.servername
                 }, &#x27;Falling back to simple HTTPS&#x27;);

  for (var i = 0; i &#x3c; this._originalSocketListeners.length; i++) {
    this._originalSocketListeners[i].call(this._server, socket);
  }

  this.emit(&#x27;connection&#x27;, socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    this.once(key, function(endpoint) {
      started = true;
      if (endpoint) {
        request._start(endpoint.createStream(), options);
      } else {
        request.<span class="apidocCodeKeywordSpan">_fallback</span>(httpsRequest);
      }
    });
  }

  return request;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.Server.prototype._start" id="apidoc.element.http2.Server.prototype._start">
        function <span class="apidocSignatureSpan">http2.Server.prototype.</span>_start
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _start(socket) {
  var endpoint = new Endpoint(this._log, &#x27;SERVER&#x27;, this._settings);

  this._log.info({ e: endpoint,
                   client: socket.remoteAddress + &#x27;:&#x27; + socket.remotePort,
                   SNI: socket.servername
                 }, &#x27;New incoming HTTP/2 connection&#x27;);

  endpoint.pipe(socket).pipe(endpoint);

  var self = this;
  endpoint.on(&#x27;stream&#x27;, function _onStream(stream) {
    var response = new OutgoingResponse(stream);
    var request = new IncomingRequest(stream);

    // Some conformance to Node.js Https specs allows to distinguish clients:
    request.remoteAddress = socket.remoteAddress;
    request.remotePort = socket.remotePort;
    request.connection = request.socket = response.socket = socket;

    request.once(&#x27;ready&#x27;, self.emit.bind(self, &#x27;request&#x27;, request, response));
  });

  endpoint.on(&#x27;error&#x27;, this.emit.bind(this, &#x27;clientError&#x27;));
  socket.on(&#x27;error&#x27;, this.emit.bind(this, &#x27;clientError&#x27;));

  this.emit(&#x27;connection&#x27;, socket, endpoint);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options.port
].join(&#x27;:&#x27;);
var self = this;

// * There&#x27;s an existing HTTP/2 connection to this host
if (key in this.endpoints) {
  var endpoint = this.endpoints[key];
  request.<span class="apidocCodeKeywordSpan">_start</span>(endpoint.createStream(), options);
}

// * HTTP/2 over plain TCP
else if (options.plain) {
  endpoint = new Endpoint(this._log, &#x27;CLIENT&#x27;, this._settings);
  endpoint.socket = net.connect({
    host: options.host,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.Server.prototype.addContext" id="apidoc.element.http2.Server.prototype.addContext">
        function <span class="apidocSignatureSpan">http2.Server.prototype.</span>addContext
        <span class="apidocSignatureSpan">(hostname, credentials)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addContext(hostname, credentials) {
  if (this._mode === &#x27;tls&#x27;) {
    this._server.addContext(hostname, credentials);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return EventEmitter.prototype.on.call(this, event, listener);
  }
};

// `addContext` is used to add Server Name Indication contexts
Server.prototype.addContext = function addContext(hostname, credentials) {
  if (this._mode === &#x27;tls&#x27;) {
    this._server.<span class="apidocCodeKeywordSpan">addContext</span>(hostname, credentials);
  }
};

Server.prototype.address = function address() {
  return this._server.address()
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.Server.prototype.address" id="apidoc.element.http2.Server.prototype.address">
        function <span class="apidocSignatureSpan">http2.Server.prototype.</span>address
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function address() {
  return this._server.address()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Server.prototype.addContext = function addContext(hostname, credentials) {
if (this._mode === &#x27;tls&#x27;) {
  this._server.addContext(hostname, credentials);
}
};

Server.prototype.address = function address() {
return this._server.<span class="apidocCodeKeywordSpan">address</span>()
};

function createServerRaw(options, requestListener) {
if (typeof options === &#x27;function&#x27;) {
  requestListener = options;
  options = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.Server.prototype.close" id="apidoc.element.http2.Server.prototype.close">
        function <span class="apidocSignatureSpan">http2.Server.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close(callback) {
  this._log.info(&#x27;Closing server&#x27;);
  this._server.close(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._server.listen.apply(this._server, arguments);

  return this._server;
};

Server.prototype.close = function close(callback) {
  this._log.info(&#x27;Closing server&#x27;);
  this._server.<span class="apidocCodeKeywordSpan">close</span>(callback);
};

Server.prototype.setTimeout = function setTimeout(timeout, callback) {
  if (this._mode === &#x27;tls&#x27;) {
    this._server.setTimeout(timeout, callback);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.Server.prototype.listen" id="apidoc.element.http2.Server.prototype.listen">
        function <span class="apidocSignatureSpan">http2.Server.prototype.</span>listen
        <span class="apidocSignatureSpan">(port, hostname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listen(port, hostname) {
  this._log.info({ on: ((typeof hostname === &#x27;string&#x27;) ? (hostname + &#x27;:&#x27; + port) : port) },
                 &#x27;Listening for incoming connections&#x27;);
  this._server.listen.apply(this._server, arguments);

  return this._server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var options = {
key: fs.readFileSync(&#x27;./example/localhost.key&#x27;),
cert: fs.readFileSync(&#x27;./example/localhost.crt&#x27;)
};

require(&#x27;http2&#x27;).createServer(options, function(request, response) {
response.end(&#x27;Hello world!&#x27;);
}).<span class="apidocCodeKeywordSpan">listen</span>(8080);
```

### Using as a client ###

```javascript
require(&#x27;http2&#x27;).get(&#x27;https://localhost:8080/&#x27;, function(response) {
response.pipe(process.stdout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.Server.prototype.on" id="apidoc.element.http2.Server.prototype.on">
        function <span class="apidocSignatureSpan">http2.Server.prototype.</span>on
        <span class="apidocSignatureSpan">(event, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, listener) {
  if ((event === &#x27;upgrade&#x27;) || (event === &#x27;timeout&#x27;)) {
    return this._server.on(event, listener &#x26;&#x26; listener.bind(this));
  } else {
    return EventEmitter.prototype.on.call(this, event, listener);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options.key = fs.readFileSync(path.join(__dirname, &#x27;/localhost.key&#x27;));
options.ca = fs.readFileSync(path.join(__dirname, &#x27;/localhost.crt&#x27;));
}

var request = process.env.HTTP2_PLAIN ? http2.raw.get(options) : http2.get(options);

// Receiving the response
request.<span class="apidocCodeKeywordSpan">on</span>(&#x27;response&#x27;, function(response) {
response.pipe(process.stdout);
response.on(&#x27;end&#x27;, finish);
});

// Receiving push streams
request.on(&#x27;push&#x27;, function(pushRequest) {
var filename = path.join(__dirname, &#x27;/push-&#x27; + push_count);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.Server.prototype.setTimeout" id="apidoc.element.http2.Server.prototype.setTimeout">
        function <span class="apidocSignatureSpan">http2.Server.prototype.</span>setTimeout
        <span class="apidocSignatureSpan">(timeout, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTimeout(timeout, callback) {
  if (this._mode === &#x27;tls&#x27;) {
    this._server.setTimeout(timeout, callback);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.Server**
//   - **Event: &#x27;checkContinue&#x27;**: not in the spec
//   - **Event: &#x27;upgrade&#x27;**: upgrade is deprecated in HTTP/2
//   - **Event: &#x27;timeout&#x27;**: HTTP/2 sockets won&#x27;t timeout because of application level keepalive
//     (PING frames)
//   - **Event: &#x27;connect&#x27;**: not yet supported
//   - **server.<span class="apidocCodeKeywordSpan">setTimeout</span>(msecs, [callback])**
//   - **server.timeout**
//
// - **Class: http2.ServerResponse**
//   - **Event: &#x27;close&#x27;**
//   - **Event: &#x27;timeout&#x27;**
//   - **response.writeContinue()**
//   - **response.writeHead(statusCode, [reasonPhrase], [headers])**: reasonPhrase will always be
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.compressor" id="apidoc.module.http2.compressor">module http2.compressor</a></h1>


    <h2>
        <a href="#apidoc.element.http2.compressor.Compressor" id="apidoc.element.http2.compressor.Compressor">
        function <span class="apidocSignatureSpan">http2.compressor.</span>Compressor
        <span class="apidocSignatureSpan">(log, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compressor(log, type) {
  TransformStream.call(this, { objectMode: true });

  this._log = log.child({ component: &#x27;compressor&#x27; });

  assert((type === &#x27;REQUEST&#x27;) || (type === &#x27;RESPONSE&#x27;));
  this._table = new HeaderTable(this._log);

  this.tableSizeChangePending = false;
  this.lowestTableSizePending = 0;
  this.tableSizeSetting = DEFAULT_HEADER_TABLE_LIMIT;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.compressor.Decompressor" id="apidoc.element.http2.compressor.Decompressor">
        function <span class="apidocSignatureSpan">http2.compressor.</span>Decompressor
        <span class="apidocSignatureSpan">(log, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decompressor(log, type) {
  TransformStream.call(this, { objectMode: true });

  this._log = log.child({ component: &#x27;compressor&#x27; });

  assert((type === &#x27;REQUEST&#x27;) || (type === &#x27;RESPONSE&#x27;));
  this._table = new HeaderTable(this._log);

  this._inProgress = false;
  this._base = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.compressor.HeaderSetCompressor" id="apidoc.element.http2.compressor.HeaderSetCompressor">
        function <span class="apidocSignatureSpan">http2.compressor.</span>HeaderSetCompressor
        <span class="apidocSignatureSpan">(log, table)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HeaderSetCompressor(log, table) {
  TransformStream.call(this, { objectMode: true });

  this._log = log.child({ component: &#x27;compressor&#x27; });
  this._table = table;
  this.push = TransformStream.prototype.push.bind(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.compressor.HeaderSetDecompressor" id="apidoc.element.http2.compressor.HeaderSetDecompressor">
        function <span class="apidocSignatureSpan">http2.compressor.</span>HeaderSetDecompressor
        <span class="apidocSignatureSpan">(log, table)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HeaderSetDecompressor(log, table) {
  TransformStream.call(this, { objectMode: true });

  this._log = log.child({ component: &#x27;compressor&#x27; });
  this._table = table;
  this._chunks = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.compressor.HeaderTable" id="apidoc.element.http2.compressor.HeaderTable">
        function <span class="apidocSignatureSpan">http2.compressor.</span>HeaderTable
        <span class="apidocSignatureSpan">(log, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HeaderTable(log, limit) {
  var self = HeaderTable.staticTable.map(entryFromPair);
  self._log = log;
  self._limit = limit || DEFAULT_HEADER_TABLE_LIMIT;
  self._staticLength = self.length;
  self._size = 0;
  self._enforceLimit = HeaderTable.prototype._enforceLimit;
  self.add = HeaderTable.prototype.add;
  self.setSizeLimit = HeaderTable.prototype.setSizeLimit;
  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.compressor.HuffmanTable" id="apidoc.element.http2.compressor.HuffmanTable">
        function <span class="apidocSignatureSpan">http2.compressor.</span>HuffmanTable
        <span class="apidocSignatureSpan">(table)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HuffmanTable(table) {
  function createTree(codes, position) {
    if (codes.length === 1) {
      return [table.indexOf(codes[0])];
    }

    else {
      position = position || 0;
      var zero = [];
      var one = [];
      for (var i = 0; i &#x3c; codes.length; i++) {
        var string = codes[i];
        if (string[position] === &#x27;0&#x27;) {
          zero.push(string);
        } else {
          one.push(string);
        }
      }
      return [createTree(zero, position + 1), createTree(one, position + 1)];
    }
  }

  this.tree = createTree(table);

  this.codes = table.map(function(bits) {
    return parseInt(bits, 2);
  });
  this.lengths = table.map(function(bits) {
    return bits.length;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.connection" id="apidoc.module.http2.connection">module http2.connection</a></h1>


    <h2>
        <a href="#apidoc.element.http2.connection.Connection" id="apidoc.element.http2.connection.Connection">
        function <span class="apidocSignatureSpan">http2.connection.</span>Connection
        <span class="apidocSignatureSpan">(log, firstStreamId, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(log, firstStreamId, settings) {
  // * initializing the base class
  Flow.call(this, 0);

  // * logging: every method uses the common logger object
  this._log = log.child({ component: &#x27;connection&#x27; });

  // * stream management
  this._initializeStreamManagement(firstStreamId);

  // * lifecycle management
  this._initializeLifecycleManagement();

  // * flow control
  this._initializeFlowControl();

  // * settings management
  this._initializeSettingsManagement(settings);

  // * multiplexing
  this._initializeMultiplexing();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.endpoint" id="apidoc.module.http2.endpoint">module http2.endpoint</a></h1>


    <h2>
        <a href="#apidoc.element.http2.endpoint.Endpoint" id="apidoc.element.http2.endpoint.Endpoint">
        function <span class="apidocSignatureSpan">http2.endpoint.</span>Endpoint
        <span class="apidocSignatureSpan">(log, role, settings, filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Endpoint(log, role, settings, filters) {
  Duplex.call(this);

  // * Initializing logging infrastructure
  this._log = log.child({ component: &#x27;endpoint&#x27;, e: this });

  // * First part of the handshake process: sending and receiving the client connection header
  //   prelude.
  assert((role === &#x27;CLIENT&#x27;) || role === &#x27;SERVER&#x27;);
  if (role === &#x27;CLIENT&#x27;) {
    this._writePrelude();
  } else {
    this._readPrelude();
  }

  // * Initialization of component. This includes the second part of the handshake process:
  //   sending the first SETTINGS frame. This is done by the connection class right after
  //   initialization.
  this._initializeDataFlow(role, settings, filters || {});

  // * Initialization of management code.
  this._initializeManagement();

  // * Initializing error handling.
  this._initializeErrorHandling();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.flow" id="apidoc.module.http2.flow">module http2.flow</a></h1>


    <h2>
        <a href="#apidoc.element.http2.flow.Flow" id="apidoc.element.http2.flow.Flow">
        function <span class="apidocSignatureSpan">http2.flow.</span>Flow
        <span class="apidocSignatureSpan">(flowControlId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Flow(flowControlId) {
  Duplex.call(this, { objectMode: true });

  this._window = this._initialWindow = INITIAL_WINDOW_SIZE;
  this._flowControlId = flowControlId;
  this._queue = [];
  this._ended = false;
  this._received = 0;
  this._blocked = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.framer" id="apidoc.module.http2.framer">module http2.framer</a></h1>


    <h2>
        <a href="#apidoc.element.http2.framer.Deserializer" id="apidoc.element.http2.framer.Deserializer">
        function <span class="apidocSignatureSpan">http2.framer.</span>Deserializer
        <span class="apidocSignatureSpan">(log, role)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Deserializer(log, role) {
  this._role = role;
  this._log = log.child({ component: &#x27;deserializer&#x27; });
  Transform.call(this, { objectMode: true });
  this._next(COMMON_HEADER_SIZE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.framer.Serializer" id="apidoc.element.http2.framer.Serializer">
        function <span class="apidocSignatureSpan">http2.framer.</span>Serializer
        <span class="apidocSignatureSpan">(log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Serializer(log) {
  this._log = log.child({ component: &#x27;serializer&#x27; });
  Transform.call(this, { objectMode: true });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.http" id="apidoc.module.http2.http">module http2.http</a></h1>


    <h2>
        <a href="#apidoc.element.http2.http.createServer" id="apidoc.element.http2.http.createServer">
        function <span class="apidocSignatureSpan">http2.http.</span>createServer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notImplemented() {
    throw new Error(&#x27;HTTP UPGRADE is not implemented!&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var options = {
  key: fs.readFileSync(&#x27;./example/localhost.key&#x27;),
  cert: fs.readFileSync(&#x27;./example/localhost.crt&#x27;)
};

require(&#x27;http2&#x27;).<span class="apidocCodeKeywordSpan">createServer</span>(options, function(request, response) {
  response.end(&#x27;Hello world!&#x27;);
}).listen(8080);
```

### Using as a client ###

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.http.get" id="apidoc.element.http2.http.get">
        function <span class="apidocSignatureSpan">http2.http.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notImplemented() {
    throw new Error(&#x27;HTTP UPGRADE is not implemented!&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  response.end(&#x27;Hello world!&#x27;);
}).listen(8080);
```

### Using as a client ###

```javascript
require(&#x27;http2&#x27;).<span class="apidocCodeKeywordSpan">get</span>(&#x27;https://localhost:8080/&#x27;, function(response
) {
  response.pipe(process.stdout);
});
```

### Simple static file server ###

An simple static file server serving up content from its own directory is available in the `example`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.http.request" id="apidoc.element.http2.http.request">
        function <span class="apidocSignatureSpan">http2.http.</span>request
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notImplemented() {
    throw new Error(&#x27;HTTP UPGRADE is not implemented!&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.Agent**
//   - **new Agent(options)**: additional option:
//     - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object
//   - **agent.sockets**: only contains TCP sockets that corresponds to HTTP/1 requests.
//   - **agent.endpoints**: contains [Endpoint](protocol/endpoint.html) objects for HTTP/2 connections.
//
// - **http2.<span class="apidocCodeKeywordSpan">request</span>(options, [callback])**:
//   - similar to http.request
//
// - **http2.get(options, [callback])**:
//   - similar to http.get
//
// - **Class: http2.ClientRequest**
//   - **Event: &#x27;socket&#x27; (socket)**: in case of an HTTP/2 incoming message, `socket` is a reference
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.https" id="apidoc.module.http2.https">module http2.https</a></h1>


    <h2>
        <a href="#apidoc.element.http2.https.createServer" id="apidoc.element.http2.https.createServer">
        function <span class="apidocSignatureSpan">http2.https.</span>createServer
        <span class="apidocSignatureSpan">(options, requestListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServerTLS(options, requestListener) {
  if (typeof options === &#x27;function&#x27;) {
    throw new Error(&#x27;options are required!&#x27;);
  }
  if (!options.pfx &#x26;&#x26; !(options.key &#x26;&#x26; options.cert)) {
    throw new Error(&#x27;options.pfx or options.key and options.cert are required!&#x27;);
  }
  options.plain = false;

  var server = new Server(options);

  if (requestListener) {
    server.on(&#x27;request&#x27;, requestListener);
  }

  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var options = {
  key: fs.readFileSync(&#x27;./example/localhost.key&#x27;),
  cert: fs.readFileSync(&#x27;./example/localhost.crt&#x27;)
};

require(&#x27;http2&#x27;).<span class="apidocCodeKeywordSpan">createServer</span>(options, function(request, response) {
  response.end(&#x27;Hello world!&#x27;);
}).listen(8080);
```

### Using as a client ###

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.https.get" id="apidoc.element.http2.https.get">
        function <span class="apidocSignatureSpan">http2.https.</span>get
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTLS(options, callback) {
  if (typeof options === &#x22;string&#x22;) {
    options = url.parse(options);
  }
  options.plain = false;
  if (options.protocol &#x26;&#x26; options.protocol !== &#x22;https:&#x22;) {
    throw new Error(&#x27;This interface only supports https-schemed URLs&#x27;);
  }
  if (options.agent &#x26;&#x26; typeof(options.agent.get) === &#x27;function&#x27;) {
    var agentOptions = util._extend({}, options);
    delete agentOptions.agent;
    return options.agent.get(agentOptions, callback);
  }
  return exports.globalAgent.get(options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  response.end(&#x27;Hello world!&#x27;);
}).listen(8080);
```

### Using as a client ###

```javascript
require(&#x27;http2&#x27;).<span class="apidocCodeKeywordSpan">get</span>(&#x27;https://localhost:8080/&#x27;, function(response
) {
  response.pipe(process.stdout);
});
```

### Simple static file server ###

An simple static file server serving up content from its own directory is available in the `example`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.https.request" id="apidoc.element.http2.https.request">
        function <span class="apidocSignatureSpan">http2.https.</span>request
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function requestTLS(options, callback) {
  if (typeof options === &#x22;string&#x22;) {
    options = url.parse(options);
  }
  options.plain = false;
  if (options.protocol &#x26;&#x26; options.protocol !== &#x22;https:&#x22;) {
    throw new Error(&#x27;This interface only supports https-schemed URLs&#x27;);
  }
  if (options.agent &#x26;&#x26; typeof(options.agent.request) === &#x27;function&#x27;) {
    var agentOptions = util._extend({}, options);
    delete agentOptions.agent;
    return options.agent.request(agentOptions, callback);
  }
  return exports.globalAgent.request(options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.Agent**
//   - **new Agent(options)**: additional option:
//     - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object
//   - **agent.sockets**: only contains TCP sockets that corresponds to HTTP/1 requests.
//   - **agent.endpoints**: contains [Endpoint](protocol/endpoint.html) objects for HTTP/2 connections.
//
// - **http2.<span class="apidocCodeKeywordSpan">request</span>(options, [callback])**:
//   - similar to http.request
//
// - **http2.get(options, [callback])**:
//   - similar to http.get
//
// - **Class: http2.ClientRequest**
//   - **Event: &#x27;socket&#x27; (socket)**: in case of an HTTP/2 incoming message, `socket` is a reference
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.protocol" id="apidoc.module.http2.protocol">module http2.protocol</a></h1>


    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint" id="apidoc.element.http2.protocol.Endpoint">
        function <span class="apidocSignatureSpan">http2.protocol.</span>Endpoint
        <span class="apidocSignatureSpan">(log, role, settings, filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Endpoint(log, role, settings, filters) {
  Duplex.call(this);

  // * Initializing logging infrastructure
  this._log = log.child({ component: &#x27;endpoint&#x27;, e: this });

  // * First part of the handshake process: sending and receiving the client connection header
  //   prelude.
  assert((role === &#x27;CLIENT&#x27;) || role === &#x27;SERVER&#x27;);
  if (role === &#x27;CLIENT&#x27;) {
    this._writePrelude();
  } else {
    this._readPrelude();
  }

  // * Initialization of component. This includes the second part of the handshake process:
  //   sending the first SETTINGS frame. This is done by the connection class right after
  //   initialization.
  this._initializeDataFlow(role, settings, filters || {});

  // * Initialization of management code.
  this._initializeManagement();

  // * Initializing error handling.
  this._initializeErrorHandling();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.protocol.Endpoint" id="apidoc.module.http2.protocol.Endpoint">module http2.protocol.Endpoint</a></h1>


    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.Endpoint" id="apidoc.element.http2.protocol.Endpoint.Endpoint">
        function <span class="apidocSignatureSpan">http2.protocol.</span>Endpoint
        <span class="apidocSignatureSpan">(log, role, settings, filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Endpoint(log, role, settings, filters) {
  Duplex.call(this);

  // * Initializing logging infrastructure
  this._log = log.child({ component: &#x27;endpoint&#x27;, e: this });

  // * First part of the handshake process: sending and receiving the client connection header
  //   prelude.
  assert((role === &#x27;CLIENT&#x27;) || role === &#x27;SERVER&#x27;);
  if (role === &#x27;CLIENT&#x27;) {
    this._writePrelude();
  } else {
    this._readPrelude();
  }

  // * Initialization of component. This includes the second part of the handshake process:
  //   sending the first SETTINGS frame. This is done by the connection class right after
  //   initialization.
  this._initializeDataFlow(role, settings, filters || {});

  // * Initialization of management code.
  this._initializeManagement();

  // * Initializing error handling.
  this._initializeErrorHandling();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.protocol.Endpoint.prototype" id="apidoc.module.http2.protocol.Endpoint.prototype">module http2.protocol.Endpoint.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.prototype._error" id="apidoc.element.http2.protocol.Endpoint.prototype._error">
        function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_error
        <span class="apidocSignatureSpan">(component, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _error(component, error) {
  this._log.fatal({ source: component, message: error }, &#x27;Fatal error, closing connection&#x27;);
  this.close(error);
  setImmediate(this.emit.bind(this, &#x27;error&#x27;, error));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// * which compares the stored header with the current `chunk` byte by byte and emits the
//   &#x27;error&#x27; event if there&#x27;s a byte that doesn&#x27;t match
var offset = cursor;
while(cursor &#x3c; CLIENT_PRELUDE.length &#x26;&#x26; (cursor - offset) &#x3c; chunk.length) {
  if (CLIENT_PRELUDE[cursor] !== chunk[cursor - offset]) {
    this._log.fatal({ cursor: cursor, offset: offset, chunk: chunk },
                    &#x27;Client connection header prelude does not match.&#x27;);
    this.<span class="apidocCodeKeywordSpan">_error</span>(&#x27;handshake&#x27;, &#x27;PROTOCOL_ERROR&#x27;);
    return;
  }
  cursor += 1;
}

// * if the whole header is over, and there were no error then restore the original `_write`
//   and call it with the remaining part of the current chunk
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.prototype._initializeDataFlow" id="apidoc.element.http2.protocol.Endpoint.prototype._initializeDataFlow">
        function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_initializeDataFlow
        <span class="apidocSignatureSpan">(role, settings, filters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _initializeDataFlow(role, settings, filters) {
  var firstStreamId, compressorRole, decompressorRole;
  if (role === &#x27;CLIENT&#x27;) {
    firstStreamId = 1;
    compressorRole = &#x27;REQUEST&#x27;;
    decompressorRole = &#x27;RESPONSE&#x27;;
  } else {
    firstStreamId = 2;
    compressorRole = &#x27;RESPONSE&#x27;;
    decompressorRole = &#x27;REQUEST&#x27;;
  }

  this._serializer   = new Serializer(this._log);
  this._deserializer = new Deserializer(this._log);
  this._compressor   = new Compressor(this._log, compressorRole);
  this._decompressor = new Decompressor(this._log, decompressorRole);
  this._connection   = new Connection(this._log, firstStreamId, settings);

  pipeAndFilter(this._connection, this._compressor, filters.beforeCompression);
  pipeAndFilter(this._compressor, this._serializer, filters.beforeSerialization);
  pipeAndFilter(this._deserializer, this._decompressor, filters.afterDeserialization);
  pipeAndFilter(this._decompressor, this._connection, filters.afterDecompression);

  this._connection.on(&#x27;ACKNOWLEDGED_SETTINGS_HEADER_TABLE_SIZE&#x27;,
                      this._decompressor.setTableSizeLimit.bind(this._decompressor));
  this._connection.on(&#x27;RECEIVING_SETTINGS_HEADER_TABLE_SIZE&#x27;,
                      this._compressor.setTableSizeLimit.bind(this._compressor));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    this._readPrelude();
  }

  // * Initialization of component. This includes the second part of the handshake process:
  //   sending the first SETTINGS frame. This is done by the connection class right after
  //   initialization.
  this.<span class="apidocCodeKeywordSpan">_initializeDataFlow</span>(role, settings, filters || {});

  // * Initialization of management code.
  this._initializeManagement();

  // * Initializing error handling.
  this._initializeErrorHandling();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.prototype._initializeErrorHandling" id="apidoc.element.http2.protocol.Endpoint.prototype._initializeErrorHandling">
        function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_initializeErrorHandling
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _initializeErrorHandling() {
  this._serializer.on(&#x27;error&#x27;, this._error.bind(this, &#x27;serializer&#x27;));
  this._deserializer.on(&#x27;error&#x27;, this._error.bind(this, &#x27;deserializer&#x27;));
  this._compressor.on(&#x27;error&#x27;, this._error.bind(this, &#x27;compressor&#x27;));
  this._decompressor.on(&#x27;error&#x27;, this._error.bind(this, &#x27;decompressor&#x27;));
  this._connection.on(&#x27;error&#x27;, this._error.bind(this, &#x27;connection&#x27;));

  this._connection.on(&#x27;peerError&#x27;, this.emit.bind(this, &#x27;peerError&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //   initialization.
  this._initializeDataFlow(role, settings, filters || {});

  // * Initialization of management code.
  this._initializeManagement();

  // * Initializing error handling.
  this.<span class="apidocCodeKeywordSpan">_initializeErrorHandling</span>();
}
Endpoint.prototype = Object.create(Duplex.prototype, { constructor: { value: Endpoint } });

// Handshake
// ---------

var CLIENT_PRELUDE = new Buffer(&#x27;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.prototype._initializeManagement" id="apidoc.element.http2.protocol.Endpoint.prototype._initializeManagement">
        function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_initializeManagement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _initializeManagement() {
  this._connection.on(&#x27;stream&#x27;, this.emit.bind(this, &#x27;stream&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // * Initialization of component. This includes the second part of the handshake process:
  //   sending the first SETTINGS frame. This is done by the connection class right after
  //   initialization.
  this._initializeDataFlow(role, settings, filters || {});

  // * Initialization of management code.
  this.<span class="apidocCodeKeywordSpan">_initializeManagement</span>();

  // * Initializing error handling.
  this._initializeErrorHandling();
}
Endpoint.prototype = Object.create(Duplex.prototype, { constructor: { value: Endpoint } });

// Handshake
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.prototype._read" id="apidoc.element.http2.protocol.Endpoint.prototype._read">
        function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _read() {
  this._readableState.sync = true;
  var moreNeeded = noread, chunk;
  while (moreNeeded &#x26;&#x26; (chunk = this._serializer.read())) {
    moreNeeded = this.push(chunk);
  }
  if (moreNeeded === noread) {
    this._serializer.once(&#x27;readable&#x27;, this._read.bind(this));
  }
  this._readableState.sync = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if ((limit === undefined) || (limit &#x3e; MAX_PAYLOAD_SIZE)) {
  limit = MAX_PAYLOAD_SIZE;
}

// * Looking at the first frame in the queue without pulling it out if possible.
var frame = this._readableState.buffer[0];
if (!frame &#x26;&#x26; !this._readableState.ended) {
  this.<span class="apidocCodeKeywordSpan">_read</span>();
  frame = this._readableState.buffer[0];
}

if (frame &#x26;&#x26; (frame.type === &#x27;DATA&#x27;)) {
  // * If the frame is DATA, then there&#x27;s two special cases:
  //   * if the limit is 0, we shouldn&#x27;t return anything
  //   * if the size of the frame is larger than limit, then the frame should be split
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.prototype._readPrelude" id="apidoc.element.http2.protocol.Endpoint.prototype._readPrelude">
        function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_readPrelude
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _readPrelude() {
  // * progress in the header is tracker using a `cursor`
  var cursor = 0;

  // * `_write` is temporarily replaced by the comparator function
  this._write = function _temporalWrite(chunk, encoding, done) {
    // * which compares the stored header with the current `chunk` byte by byte and emits the
    //   &#x27;error&#x27; event if there&#x27;s a byte that doesn&#x27;t match
    var offset = cursor;
    while(cursor &#x3c; CLIENT_PRELUDE.length &#x26;&#x26; (cursor - offset) &#x3c; chunk.length) {
      if (CLIENT_PRELUDE[cursor] !== chunk[cursor - offset]) {
        this._log.fatal({ cursor: cursor, offset: offset, chunk: chunk },
                        &#x27;Client connection header prelude does not match.&#x27;);
        this._error(&#x27;handshake&#x27;, &#x27;PROTOCOL_ERROR&#x27;);
        return;
      }
      cursor += 1;
    }

    // * if the whole header is over, and there were no error then restore the original `_write`
    //   and call it with the remaining part of the current chunk
    if (cursor === CLIENT_PRELUDE.length) {
      this._log.debug(&#x27;Successfully received the client connection header prelude.&#x27;);
      delete this._write;
      chunk = chunk.slice(cursor - offset);
      this._write(chunk, encoding, done);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// * First part of the handshake process: sending and receiving the client connection header
//   prelude.
assert((role === &#x27;CLIENT&#x27;) || role === &#x27;SERVER&#x27;);
if (role === &#x27;CLIENT&#x27;) {
  this._writePrelude();
} else {
  this.<span class="apidocCodeKeywordSpan">_readPrelude</span>();
}

// * Initialization of component. This includes the second part of the handshake process:
//   sending the first SETTINGS frame. This is done by the connection class right after
//   initialization.
this._initializeDataFlow(role, settings, filters || {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.prototype._write" id="apidoc.element.http2.protocol.Endpoint.prototype._write">
        function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_write
        <span class="apidocSignatureSpan">(chunk, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _write(chunk, encoding, done) {
  this._deserializer.write(chunk, encoding, done);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // * if the whole header is over, and there were no error then restore the original `_write`
    //   and call it with the remaining part of the current chunk
    if (cursor === CLIENT_PRELUDE.length) {
      this._log.debug(&#x27;Successfully received the client connection header prelude.&#x27;);
      delete this._write;
      chunk = chunk.slice(cursor - offset);
      this.<span class="apidocCodeKeywordSpan">_write</span>(chunk, encoding, done);
    }
  };
};

// Data flow
// ---------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.prototype._writePrelude" id="apidoc.element.http2.protocol.Endpoint.prototype._writePrelude">
        function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>_writePrelude
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _writePrelude() {
  this._log.debug(&#x27;Sending the client connection header prelude.&#x27;);
  this.push(CLIENT_PRELUDE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// * Initializing logging infrastructure
this._log = log.child({ component: &#x27;endpoint&#x27;, e: this });

// * First part of the handshake process: sending and receiving the client connection header
//   prelude.
assert((role === &#x27;CLIENT&#x27;) || role === &#x27;SERVER&#x27;);
if (role === &#x27;CLIENT&#x27;) {
  this.<span class="apidocCodeKeywordSpan">_writePrelude</span>();
} else {
  this._readPrelude();
}

// * Initialization of component. This includes the second part of the handshake process:
//   sending the first SETTINGS frame. This is done by the connection class right after
//   initialization.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.prototype.close" id="apidoc.element.http2.protocol.Endpoint.prototype.close">
        function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>close
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close(error) {
  this._connection.close(error);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._server.listen.apply(this._server, arguments);

  return this._server;
};

Server.prototype.close = function close(callback) {
  this._log.info(&#x27;Closing server&#x27;);
  this._server.<span class="apidocCodeKeywordSpan">close</span>(callback);
};

Server.prototype.setTimeout = function setTimeout(timeout, callback) {
  if (this._mode === &#x27;tls&#x27;) {
    this._server.setTimeout(timeout, callback);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.protocol.Endpoint.prototype.createStream" id="apidoc.element.http2.protocol.Endpoint.prototype.createStream">
        function <span class="apidocSignatureSpan">http2.protocol.Endpoint.prototype.</span>createStream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStream() {
  return this._connection.createStream();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  options.port
].join(&#x27;:&#x27;);
var self = this;

// * There&#x27;s an existing HTTP/2 connection to this host
if (key in this.endpoints) {
  var endpoint = this.endpoints[key];
  request._start(endpoint.<span class="apidocCodeKeywordSpan">createStream</span>(), options);
}

// * HTTP/2 over plain TCP
else if (options.plain) {
  endpoint = new Endpoint(this._log, &#x27;CLIENT&#x27;, this._settings);
  endpoint.socket = net.connect({
    host: options.host,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.raw" id="apidoc.module.http2.raw">module http2.raw</a></h1>


    <h2>
        <a href="#apidoc.element.http2.raw.createServer" id="apidoc.element.http2.raw.createServer">
        function <span class="apidocSignatureSpan">http2.raw.</span>createServer
        <span class="apidocSignatureSpan">(options, requestListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServerRaw(options, requestListener) {
  if (typeof options === &#x27;function&#x27;) {
    requestListener = options;
    options = {};
  }

  if (options.pfx || (options.key &#x26;&#x26; options.cert)) {
    throw new Error(&#x27;options.pfx, options.key, and options.cert are nonsensical!&#x27;);
  }

  options.plain = true;
  var server = new Server(options);

  if (requestListener) {
    server.on(&#x27;request&#x27;, requestListener);
  }

  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var options = {
  key: fs.readFileSync(&#x27;./example/localhost.key&#x27;),
  cert: fs.readFileSync(&#x27;./example/localhost.crt&#x27;)
};

require(&#x27;http2&#x27;).<span class="apidocCodeKeywordSpan">createServer</span>(options, function(request, response) {
  response.end(&#x27;Hello world!&#x27;);
}).listen(8080);
```

### Using as a client ###

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.raw.get" id="apidoc.element.http2.raw.get">
        function <span class="apidocSignatureSpan">http2.raw.</span>get
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRaw(options, callback) {
  if (typeof options === &#x22;string&#x22;) {
    options = url.parse(options);
  }
  options.plain = true;
  if (options.protocol &#x26;&#x26; options.protocol !== &#x22;http:&#x22;) {
    throw new Error(&#x27;This interface only supports http-schemed URLs&#x27;);
  }
  if (options.agent &#x26;&#x26; typeof(options.agent.get) === &#x27;function&#x27;) {
    var agentOptions = util._extend({}, options);
    delete agentOptions.agent;
    return options.agent.get(agentOptions, callback);
  }
  return exports.globalAgent.get(options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  response.end(&#x27;Hello world!&#x27;);
}).listen(8080);
```

### Using as a client ###

```javascript
require(&#x27;http2&#x27;).<span class="apidocCodeKeywordSpan">get</span>(&#x27;https://localhost:8080/&#x27;, function(response
) {
  response.pipe(process.stdout);
});
```

### Simple static file server ###

An simple static file server serving up content from its own directory is available in the `example`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.raw.request" id="apidoc.element.http2.raw.request">
        function <span class="apidocSignatureSpan">http2.raw.</span>request
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function requestRaw(options, callback) {
  if (typeof options === &#x22;string&#x22;) {
    options = url.parse(options);
  }
  options.plain = true;
  if (options.protocol &#x26;&#x26; options.protocol !== &#x22;http:&#x22;) {
    throw new Error(&#x27;This interface only supports http-schemed URLs&#x27;);
  }
  if (options.agent &#x26;&#x26; typeof(options.agent.request) === &#x27;function&#x27;) {
    var agentOptions = util._extend({}, options);
    delete agentOptions.agent;
    return options.agent.request(agentOptions, callback);
  }
  return exports.globalAgent.request(options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// - **Class: http2.Agent**
//   - **new Agent(options)**: additional option:
//     - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object
//   - **agent.sockets**: only contains TCP sockets that corresponds to HTTP/1 requests.
//   - **agent.endpoints**: contains [Endpoint](protocol/endpoint.html) objects for HTTP/2 connections.
//
// - **http2.<span class="apidocCodeKeywordSpan">request</span>(options, [callback])**:
//   - similar to http.request
//
// - **http2.get(options, [callback])**:
//   - similar to http.get
//
// - **Class: http2.ClientRequest**
//   - **Event: &#x27;socket&#x27; (socket)**: in case of an HTTP/2 incoming message, `socket` is a reference
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.serializers" id="apidoc.module.http2.serializers">module http2.serializers</a></h1>


    <h2>
        <a href="#apidoc.element.http2.serializers.data" id="apidoc.element.http2.serializers.data">
        function <span class="apidocSignatureSpan">http2.serializers.</span>data
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">data = function (data) {
  return data.toString(&#x27;hex&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.serializers.e" id="apidoc.element.http2.serializers.e">
        function <span class="apidocSignatureSpan">http2.serializers.</span>e
        <span class="apidocSignatureSpan">(endpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">e = function (endpoint) {
  if (!(&#x27;id&#x27; in endpoint)) {
    endpoint.id = nextId;
    nextId += 1;
  }
  return endpoint.id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.serializers.frame" id="apidoc.element.http2.serializers.frame">
        function <span class="apidocSignatureSpan">http2.serializers.</span>frame
        <span class="apidocSignatureSpan">(frame)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">frame = function (frame) {
  if (!frame) {
    return null;
  }

  if (&#x27;id&#x27; in frame) {
    return frame.id;
  }

  frame.id = frameCounter;
  frameCounter += 1;

  var logEntry = { id: frame.id };
  genericAttributes.concat(typeSpecificAttributes[frame.type]).forEach(function(name) {
    logEntry[name] = frame[name];
  });

  if (frame.data instanceof Buffer) {
    if (logEntry.data.length &#x3e; 50) {
      logEntry.data = frame.data.slice(0, 47).toString(&#x27;hex&#x27;) + &#x27;...&#x27;;
    } else {
      logEntry.data = frame.data.toString(&#x27;hex&#x27;);
    }

    if (!(&#x27;length&#x27; in logEntry)) {
      logEntry.length = frame.data.length;
    }
  }

  if (frame.promised_stream instanceof Object) {
    logEntry.promised_stream = &#x27;stream-&#x27; + frame.promised_stream.id;
  }

  logEntry.flags = Object.keys(frame.flags || {}).filter(function(name) {
    return frame.flags[name] === true;
  });

  return logEntry;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.http2.serializers.s" id="apidoc.element.http2.serializers.s">
        function <span class="apidocSignatureSpan">http2.serializers.</span>s
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">s = function (stream) {
  if (!(&#x27;_id&#x27; in stream)) {
    stream._id = nextId;
    nextId += 1;
  }
  return stream._id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.http2.stream" id="apidoc.module.http2.stream">module http2.stream</a></h1>


    <h2>
        <a href="#apidoc.element.http2.stream.Stream" id="apidoc.element.http2.stream.Stream">
        function <span class="apidocSignatureSpan">http2.stream.</span>Stream
        <span class="apidocSignatureSpan">(log, connection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream(log, connection) {
  Duplex.call(this);

  // * logging
  this._log = log.child({ component: &#x27;stream&#x27;, s: this });

  // * receiving and sending stream management commands
  this._initializeManagement();

  // * sending and receiving frames to/from the upstream connection
  this._initializeDataFlow();

  // * maintaining the state of the stream (idle, open, closed, etc.) and error detection
  this._initializeState();

  this.connection = connection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
